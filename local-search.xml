<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>react课程2-kick off</title>
    <link href="/2024/08/11/react%E8%AF%BE%E7%A8%8B2-kick-off/"/>
    <url>/2024/08/11/react%E8%AF%BE%E7%A8%8B2-kick-off/</url>
    
    <content type="html"><![CDATA[<p>开始整合比较小的页面</p><span id="more"></span><p>最好不要嵌套函数声明</p><h3 id="一、Babel"><a href="#一、Babel" class="headerlink" title="一、Babel"></a>一、Babel</h3><p>Babel 是一个广泛使用的 JavaScript 编译器，主要用于将现代 JavaScript 代码（ES6+）转换为与旧浏览器兼容的代码。它能够将新版本的 JavaScript 语法和特性编译为更旧版本，从而确保代码可以在不支持这些新特性的环境中运行。</p><p>Babel 的主要功能包括：</p><ol><li><strong>语法转换</strong>：将现代 JavaScript 语法（如箭头函数、类、模板字符串等）转换为较旧的等效代码。</li><li><strong>插件系统</strong>：Babel 提供了一个强大的插件系统，用户可以根据需要定制 Babel 的行为，例如添加支持 TypeScript、React JSX 等。</li><li><strong>Polyfill</strong>：通过 <code>@babel/polyfill</code>，可以在旧浏览器中引入新 JavaScript 标准库功能（如 Promise、Map 等）。</li><li><strong>代码转换</strong>：Babel 还可以用于代码的其他转换，例如重命名变量、删除未使用的代码等。</li></ol><p>在 React 项目中，Babel 通常与 Webpack 一起使用，通过配置 Babel Loader 来处理 JavaScript 文件的转换，使得开发者可以使用最新的 JavaScript 特性进行开发，同时确保代码的兼容性。</p><h3 id="二、webpack"><a href="#二、webpack" class="headerlink" title="二、webpack"></a>二、webpack</h3><p>Webpack 是一个现代 JavaScript 应用的模块打包工具（bundler）。它的主要功能是将各种资源（JavaScript、CSS、图片等）作为模块进行打包，从而生成可以在浏览器中运行的文件。Webpack 的核心思想是把所有的项目资源都视为模块，无论是 JavaScript 代码、样式表还是图片等资源，最终打包成一个或多个输出文件，以便在浏览器中更高效地加载。</p><p>以下是 Webpack 的一些核心概念：</p><ol><li><strong>Entry（入口）</strong>：<ul><li>Webpack 从一个或多个入口文件开始构建依赖关系图，找出项目中所有的模块及其依赖关系。</li><li>默认入口文件是 <code>./src/index.js</code>，但可以通过 Webpack 配置文件 (<code>webpack.config.js</code>) 来指定。</li></ul></li><li><strong>Output（输出）</strong>：<ul><li>配置输出文件的名称和路径。打包后的文件通常命名为 <code>bundle.js</code>，但也可以自定义。</li><li>例如，将输出文件放在 <code>./dist</code> 目录下。</li></ul></li><li><strong>Loaders（加载器）</strong>：<ul><li>Loaders 用于转换不同类型的模块，如将 ES6+ 的 JavaScript 转换为兼容的 ES5，或者将 SCSS 文件编译为 CSS。</li><li>常用的加载器有 <code>babel-loader</code>（处理 JavaScript）、<code>css-loader</code>（处理 CSS）、<code>file-loader</code>（处理文件资源）等。</li></ul></li><li><strong>Plugins（插件）</strong>：<ul><li>插件用于执行复杂的任务，如优化打包文件的大小、生成 HTML 文件、提取 CSS 文件等。</li><li>常见的插件有 <code>HtmlWebpackPlugin</code>（生成 HTML 文件）、<code>MiniCssExtractPlugin</code>（提取 CSS 到单独文件）、<code>UglifyJsPlugin</code>（压缩 JavaScript 文件）等。</li></ul></li><li><strong>Mode（模式）</strong>：<ul><li>Webpack 提供了两种模式：<code>development</code> 和 <code>production</code>。</li><li><code>development</code> 模式适用于开发环境，具有更好的调试体验，代码不会被压缩。</li><li><code>production</code> 模式适用于生产环境，代码会被优化和压缩，以提高性能。</li></ul></li><li><strong>DevServer</strong>：<ul><li>Webpack DevServer 是一个开发服务器，它可以实时重新加载页面，提供热模块替换（Hot Module Replacement，HMR）功能，使开发过程更加高效。</li></ul></li></ol><p>在实际应用中，Webpack 通常与 Babel、Sass、PostCSS 等工具结合使用，以构建现代 Web 应用程序。通过配置 Webpack，你可以在开发过程中享受模块化开发的便利，同时确保最终生成的文件在性能和兼容性上达到最佳状态。</p><h3 id="三、React的分离特性"><a href="#三、React的分离特性" class="headerlink" title="三、React的分离特性"></a>三、React的分离特性</h3><p>React 框架的确与传统的分离式（HTML、CSS、JavaScript 分离）开发方式有所不同。在 React 中，开发者通常会将逻辑、结构和样式组合在一个组件内，使用 JavaScript 来创建用户界面。这种方法称为<strong>组件化开发</strong>，其核心理念是将 UI 拆分为独立、可复用的组件。</p><p>尽管 React 不再像传统方式那样严格分离 HTML、CSS、JS，但它依然在不同层次上体现了分离性：</p><ol><li><strong>组件分离</strong></li></ol><ul><li>React 强调将页面分解成多个独立的组件，每个组件只负责自己的功能和状态管理。这种分离方式使得代码更加模块化和可维护。</li><li>每个组件可以包含自己的结构（HTML）、样式（CSS）、逻辑（JS），并且可以独立开发、测试和复用。</li></ul><ol start="2"><li><strong>JSX 的语义分离</strong></li></ol><ul><li>在 React 中，JSX 允许开发者在 JavaScript 中编写类似 HTML 的语法。尽管看似混合了 HTML 和 JavaScript，但其实 JSX 只是 React 的语法糖，最终会被编译成纯 JavaScript。</li><li>通过 JSX，结构化的 UI 代码嵌入在 JavaScript 中，但仍然保持了逻辑和展示之间的清晰分离。代码语义化也得到了增强，因为 JSX 语法比传统的字符串拼接方式更直观。</li></ul><ol start="3"><li><strong>CSS-in-JS</strong></li></ol><ul><li>React 生态中有许多样式解决方案，比如 styled-components、emotion，它们允许在 JavaScript 文件中编写样式。这种方式使样式与组件逻辑紧密绑定，避免了传统全局 CSS 带来的样式冲突问题。</li><li>CSS-in-JS 提供了样式的局部作用域（scoped styling），从而实现了样式的隔离和组件化管理。</li></ul><ol start="4"><li><strong>Context 和 Hooks 的逻辑分离</strong></li></ol><ul><li>React 提供了 Context 和 Hooks，使得状态管理和业务逻辑可以与 UI 组件分离。例如，使用 <code>useContext</code> 和 <code>useReducer</code> 等 Hook，可以将全局状态逻辑与具体组件解耦，从而提高代码的可读性和复用性。</li><li>通过自定义 Hooks，开发者可以将可复用的逻辑抽取出来，并在多个组件中共享，而不需要重复代码。</li></ul><ol start="5"><li><strong>CSS Modules</strong></li></ol><ul><li>CSS Modules 是 React 中另一种常用的样式解决方案，它允许开发者将样式分离成各个模块，并自动为每个模块生成唯一的类名，以避免样式冲突。</li><li>使用 CSS Modules 时，样式文件仍然可以保持与组件分离，同时确保了样式的作用范围只限于当前组件。</li></ul><ol start="6"><li><strong>文件结构的分离</strong></li></ol><ul><li>虽然 React 鼓励在组件内部进行组合，但开发者依然可以根据项目需求将组件、样式和逻辑代码分布在不同的文件中。</li><li>例如，可以有一个 <code>components</code> 文件夹来存放组件，一个 <code>styles</code> 文件夹来存放样式文件，一个 <code>services</code> 文件夹来处理业务逻辑和 API 请求。</li></ul><p>React 中的“分离性”更多地体现在逻辑层次的分离，而非文件层次的分离。通过组件化开发、JSX、CSS-in-JS、Context、Hooks 等机制，React 保持了代码的模块化和可维护性，即使结构、样式和逻辑被合并在一起。这种方式更适合现代前端开发的需求，提供了更好的代码组织方式和开发体验。</p><h3 id="四、重用组件的代码实例"><a href="#四、重用组件的代码实例" class="headerlink" title="四、重用组件的代码实例"></a>四、重用组件的代码实例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Menu</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Our menu<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;pizza&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Pizza</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Pizza Spinaci&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">ingredients</span>=<span class="hljs-string">&quot;Tomato, mozarella, spinach, and ricotta cheese&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">photoName</span>=<span class="hljs-string">&quot;pizzas\spinaci.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">price</span>=<span class="hljs-string">&#123;10&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Pizza</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Pizza Funghi&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">ingredients</span>=<span class="hljs-string">&quot;Tomato, mozarella, mushrooms, and onion&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">price</span>=<span class="hljs-string">&#123;12&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">photoName</span>=<span class="hljs-string">&quot;pizzas/funghi.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Pizza</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.photoName&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.name&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;props.ingredients&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;props.price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react课程1-kick off</title>
    <link href="/2024/08/08/react%E8%AF%BE%E7%A8%8B1-/"/>
    <url>/2024/08/08/react%E8%AF%BE%E7%A8%8B1-/</url>
    
    <content type="html"><![CDATA[<p>处理数据+在用户界面展示数据——&gt;<strong>用户界面(user interface)与数据同步</strong></p><p>react课程kick off </p><span id="more"></span><h3 id="一、react简介"><a href="#一、react简介" class="headerlink" title="一、react简介"></a>一、react简介</h3><p>处理数据+在用户界面展示数据——&gt;用户界面(user interface)与数据同步</p><p>react基本上是关于component的，它的基本任务就是<strong>获取组件的当前状态并将它们绘制在web界面上</strong>。另外一件对组件做的事情就是：<strong>重用</strong>（）。以及<strong>组件嵌套</strong>。</p><p>远离DOM的纯净的JS。——&gt;JXS</p><p>如何很好地响应变化？：<strong>state</strong></p><p>react实际上是一个库。</p><p>建立在react上的框架：Next.js和Remix</p><p>迄今为止最受欢迎的框架：1、许多大型公司很久之前就已经开始使用react；2、拥有巨大的就业市场和很高的需求；3、拥有许多专业社区为开发人员提供支持</p><p>最初是起源于社交软件。</p><h3 id="二、Node-JS"><a href="#二、Node-JS" class="headerlink" title="二、Node.JS"></a>二、Node.JS</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。它使得 JavaScript 不仅可以在浏览器中运行，还可以在服务器端运行。简单来说，Node.js 让你能够使用 JavaScript 编写服务器端应用程序。以下是 Node.js 的主要用途和特点：</p><ol><li><strong>服务器端编程</strong></li></ol><ul><li>使用 Node.js 可以编写服务器端代码，这意味着你可以用 JavaScript 创建后台服务、处理请求和响应、管理数据库等。Node.js 常用于构建 RESTful API、Web 应用程序、实时聊天应用等。</li></ul><ol start="2"><li><strong>事件驱动与非阻塞 I&#x2F;O</strong></li></ol><ul><li>Node.js 的最大特点之一是其事件驱动和非阻塞 I&#x2F;O 模型。这使得它非常适合处理高并发的请求，比如需要同时处理大量连接的服务器。因为它是非阻塞的，所以即使有大量请求同时到来，Node.js 也不会因为某个请求在等待数据而阻塞其他请求。</li></ul><ol start="3"><li><strong>全栈开发</strong></li></ol><ul><li>由于 Node.js 使用 JavaScript 语言，前端开发人员可以在掌握 JavaScript 的基础上，无缝地过渡到后端开发，实现全栈开发。比如使用 Express 框架可以很方便地创建和管理后端服务。</li></ul><ol start="4"><li><strong>丰富的包生态系统</strong></li></ol><ul><li>Node.js 具有一个庞大的包管理系统，即 npm（Node Package Manager）。通过 npm，开发者可以访问数十万计的开源包和模块，大大简化了开发过程。例如，使用 <code>express</code> 可以快速搭建 web 服务器，使用 <code>mongoose</code> 可以轻松操作 MongoDB 数据库。</li></ul><ol start="5"><li><strong>跨平台</strong></li></ol><ul><li>Node.js 是跨平台的，可以在 Windows、Linux、macOS 等操作系统上运行，这使得它成为了一个非常灵活的开发工具。</li></ul><ol start="6"><li><strong>实时应用</strong></li></ol><ul><li>Node.js 非常适合开发实时应用程序，比如聊天室、在线游戏、协同工具等，因为它能处理大量的并发连接并且响应速度非常快。</li></ul><ol start="7"><li><strong>开发工具和构建工具</strong></li></ol><ul><li>Node.js 也被广泛用于开发工具的构建，如 webpack、gulp 等，帮助前端开发者进行项目的打包、构建、测试和部署。</li></ul><p><strong>举例应用场景：</strong></p><ul><li><strong>Web 服务器</strong>：使用 Express.js 创建的 Web 应用。</li><li><strong>API 服务</strong>：RESTful API，用于与数据库交互并提供数据服务。</li><li><strong>实时应用</strong>：聊天应用、协同编辑工具（如 Google Docs）。</li><li><strong>开发工具</strong>：前端打包工具（如 Webpack）、任务运行器（如 Gulp）。</li></ul><p>总之，Node.js 是一个强大的工具，适合需要高并发处理和实时交互的应用场景，尤其是在 Web 开发领域有着广泛的应用。</p><h3 id="三、准备工作"><a href="#三、准备工作" class="headerlink" title="三、准备工作"></a>三、准备工作</h3><p>（1）安装 VS code的依赖：</p><p>1、ESlint（发现bug）</p><p>2、Prettier（自动格式化代码使其更美观）</p><p>3、One Monokai Theme</p><p>4、material icon Theme</p><p>（2）设置</p><p>auto save调整为  onFocusChange</p><p>default Formatter调整为Prettier</p><p>Format on save打开</p><p>eslint run改为on save</p><p>（3）快捷键</p><p>1、新建一个空的HTML文件时，输入！点击Enter就会构建出一个空的HTML结构</p><p>（4）安装好npm 以及npm依赖，下载react-start-app@5来创建项目，<strong>npm start</strong>来运行项目</p>]]></content>
    
    
    <categories>
      
      <category>react课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发课程3--HTML and CSS</title>
    <link href="/2024/08/04/web%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B3--HTML-and-CSS/"/>
    <url>/2024/08/04/web%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B3--HTML-and-CSS/</url>
    
    <content type="html"><![CDATA[<p>本次课程学习HTML和CSS</p><span id="more"></span><h3 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h3><p>1、</p><p>Hypertext markup language（超文本标记语言）</p><p>是网络浏览器用来描述网页内容和结构的语言，是网页的骨架和核心结构，也可以把它看作嵌套的盒子。</p><p>div就像一个空白的画布..</p><p>but..accessibility, not descriptive. It’s ambiguous（模糊的）, hard to organize, hard to target（定位）, bad style, too cluttered（乱）, it’s more work.</p><p>利用<strong>MDN</strong>网站学习！更新速度很快…</p><h3 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">color</span>: red;<br>   <span class="hljs-attribute">font-family</span>: Arial;<br>   <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24pt</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ID  vs  Class</p><p>Only one   VS    Multiple</p><p>建议只使用类</p><p>utility classes 实用类：只使用一个CSS属性修改</p><p>fonts.google.com  字体网页</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/976789a0-8f9b-11eb-85f6-6fac77c0c9b3.png" alt="面试官：说说你对盒子模型的理解? | web前端面试- 面试官系列" style="zoom: 50%;" /><p>定义空间元素的方式</p><p>weblab.to&#x2F;flex</p>]]></content>
    
    
    <categories>
      
      <category>web开发课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发课程2--Command line and Git</title>
    <link href="/2024/08/04/web%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2--Command-line-and-Git/"/>
    <url>/2024/08/04/web%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2--Command-line-and-Git/</url>
    
    <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240804145935038.png" alt="image-20240804145935038" style="zoom:80%;" /><p>go over Command line  and use command lines to run some Git commands and learn about Git as well.</p><span id="more"></span><h3 id="一、命令行语句"><a href="#一、命令行语句" class="headerlink" title="一、命令行语句"></a>一、命令行语句</h3><p>pwd：print working directory（当前工作目录）<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240804150539650.png" alt="image-20240804150539650" style="zoom: 67%;" /></p><p>rm file name：remove</p><p>touch f n：creat </p><p>mkdir folder name:creat a folder</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240804151036413.png" alt="image-20240804151036413" style="zoom: 67%;" /><h3 id="二、Git——A-version-control-system"><a href="#二、Git——A-version-control-system" class="headerlink" title="二、Git——A version-control system"></a>二、Git——A version-control system</h3><h4 id="（1）problems-with-coding-in-projects"><a href="#（1）problems-with-coding-in-projects" class="headerlink" title="（1）problems with coding in projects"></a>（1）problems with coding in projects</h4><ol><li>Synchronization（同步） of files (no one knows which file is the most up-to-date)</li><li>Collaboration（合作） of files (if there are two version of the same file, both of them fix a different problem, it’s hard to know how to join the files)</li><li>Version history (if we break something, we can’t go back to a working copy)</li></ol><h4 id="（2）what-does-git-do？-基本原理"><a href="#（2）what-does-git-do？-基本原理" class="headerlink" title="（2）what does git do？(基本原理)"></a>（2）what does git do？(基本原理)</h4><p>track changes  by doing math(computing the <strong>difference</strong> every time you make changes)</p><h4 id="（3）some-terminology（基本术语）"><a href="#（3）some-terminology（基本术语）" class="headerlink" title="（3）some terminology（基本术语）"></a>（3）some terminology（基本术语）</h4><p>1.<strong>Repository</strong>—— a set of files to track changes on(git仓库)</p><p>2.<strong>Commit</strong>——a set of  changes in a repository transitioning from one version to the next</p><p>3.<strong>Log</strong>——the set of commits for each version of the repository</p><ul><li>commit (n.)- a packaged set of changes</li><li>push (v.)- to send commits to the git server</li><li>pull (V.)- to get most updated files from the git server</li></ul><p>           </p><h3 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h3><p>git init</p><p>git status</p><p>git remote add origin <code>https://github.com/Yaodeer/catbook-react</code>(连接远程仓库)</p><p>git push </p><p>一些命令行语句：</p><p><a href="https://training.github.com/downloads/github-git-cheat-sheet/">GitHub Git Cheat Sheet - GitHub Cheatsheets</a></p><p>git clone了工程到电脑上并连接到了我自己的仓库，默认分支main：</p><p><code>git clone https://github.com/weblab-workshops/catbook-react.git</code></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>web开发课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发课程1--kick off</title>
    <link href="/2024/08/04/web%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1--kick-off/"/>
    <url>/2024/08/04/web%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1--kick-off/</url>
    
    <content type="html"><![CDATA[<p>准备花时间跟学一下MIT的web开发课程，希望可以坚持下去。本篇主要是着手学习之前需要了解的内容。</p><span id="more"></span><p>作业链接：<a href="https://gaudy-basketball-f66.notion.site/web-lab-Students-Page-2f46514f5dd441acbde22a3ae36d60ff">web.lab Students Page! (notion.site)</a></p><h3 id="一、课程安排"><a href="#一、课程安排" class="headerlink" title="一、课程安排"></a>一、课程安排</h3><p>week1——build an app from scratch together</p><p>week2——advanced topics</p><p>week3——code code code</p><p>week4——CODE CODE CODE</p><h3 id="二、简述"><a href="#二、简述" class="headerlink" title="二、简述"></a>二、简述</h3><p>HTML——build the structure of your website that contains all the components(组件) that we see and all the information、all the text images things like that.</p><p>CSS（Cascading Style Sheets层叠样式表）——basically tells the website how to look,how to make it look good</p><p>JavaScript——provides any sort of motion or information of fetching,so it can make your website more interactive and functional(功能性的)</p><p>Assets（资源）——like images,videos</p><h3 id="三、要求"><a href="#三、要求" class="headerlink" title="三、要求"></a>三、要求</h3><p>1、Functionally</p><p>2、Usability</p><p>3、Aesthetics</p><p>4、Concept Exection</p>]]></content>
    
    
    <categories>
      
      <category>web开发课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot学习记录</title>
    <link href="/2024/07/31/springboot%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/07/31/springboot%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>.<span id="more"></span></p><h3 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>1）搜索springboot.io查找使用手册（全英的我很难看懂……）</p><p>2）springboot提供了一种快速开发spring项目的方式（自动配置、起步依赖（Maven））</p><p>3）springboot项目构建时采用jar的打包方式</p><p>4）start.spring.io   在官网配置spring boot项目</p><p>5）sout——system.out.println</p><h4 id="2、实现基本案例"><a href="#2、实现基本案例" class="headerlink" title="2、实现基本案例"></a>2、实现基本案例</h4><p>搭建springboot工程，定义HelloController.hello()方法，返回指定内容。</p><p>1）创建Maven项目</p><p>2）导入SpringBoot起步依赖（创建项目时勾选SpringWeb和Thymeleaf依赖）</p><p>3）定义Controller</p><p>4）编写引导类（现在版本自动生成，是Springboot项目的入口）</p><p>5）启动测试</p><h4 id="3、起步依赖原理"><a href="#3、起步依赖原理" class="headerlink" title="3、起步依赖原理"></a>3、起步依赖原理</h4><p>1）在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。</p><p>2）在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。</p><p>3）我们的忠诚继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题。</p><h3 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h3><p>spring boot是基于约定的，所以很多配置都有默认值，如果想用自己的配置替换默认值，就可以用application.properties或者application.yml（&#x2F;yaml）进行配置。</p><h4 id="1、两种配置文件"><a href="#1、两种配置文件" class="headerlink" title="1、两种配置文件"></a>1、两种配置文件</h4><p>properties：   server.port&#x3D;8085（键&#x3D;值）</p><p>yml&#x2F;yaml:          server:                           （换行缩进）</p><p>​                      port: 8080</p><p>在同一级目录下的优先级：properties&gt;yml&gt;yaml</p><h4 id="2、YAML文件是以数据为核心的，比xml更加简洁，相对于properties来说更容易看出配置属于哪个层级。"><a href="#2、YAML文件是以数据为核心的，比xml更加简洁，相对于properties来说更容易看出配置属于哪个层级。" class="headerlink" title="2、YAML文件是以数据为核心的，比xml更加简洁，相对于properties来说更容易看出配置属于哪个层级。"></a>2、<strong>YAML</strong>文件是以数据为核心的，比xml更加简洁，相对于properties来说更容易看出配置属于哪个层级。</h4><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240801145449469.png" alt="image-20240801145449469" style="zoom:67%;" /><p>   1）大小写敏感、2）数值前必须有空格作为分隔符、3）缩进代表层级关系，不能使用Tab，只能使用空格，空格数不重要，只需要相同层级的元素左侧对齐即可。4）#表注释</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240801150220414.png" alt="image-20240801150220414" style="zoom:67%;" /><p>参数引用： ${key}</p><h4 id="3、配置文件读取"><a href="#3、配置文件读取" class="headerlink" title="3、配置文件读取"></a>3、配置文件读取</h4><p><em>三种方法</em></p><p>​@value</p><p>​Environment</p><p>​@ConfigurationProperties:是我们配置文件的内容和对象做映射</p><h5 id="（1）读取实例方法一（-value）"><a href="#（1）读取实例方法一（-value）" class="headerlink" title="（1）读取实例方法一（@value）"></a>（1）读取实例方法一（@value）</h5><p>如果想要在&#x2F;hello路径输出一个字符串，controller文件可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.demoa;<br><br>#<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span>      <span class="hljs-comment">//RESTful控制器，返回JSON数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>   <br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Spring Boot!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要读取配置文件，可以将文件修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.demoa;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span>      <span class="hljs-comment">//RESTful控制器，返回JSON数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>   <span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span> <br>   <span class="hljs-keyword">private</span> String name;   <span class="hljs-comment">//读取name的赋给字符串name</span><br>   <span class="hljs-meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span>    <br>   <span class="hljs-keyword">private</span> String name1;<br>   <span class="hljs-meta">@Value(&quot;$&#123;address[1]&#125;&quot;)</span>   <span class="hljs-comment">//读取数组的第一个值</span><br>   <span class="hljs-keyword">private</span> String name2;<br>   <span class="hljs-meta">@RequestMapping(&quot;/hello2&quot;)</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(name);     <span class="hljs-comment">//输出name的值，在控制台可以看到输出</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Spring Boot!&quot;</span>;<br>   &#125;<br>   <br>   <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Spring Boot!&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-01%20161321.png"  /><h5 id="（2）读取配置方法二（Environment）"><a href="#（2）读取配置方法二（Environment）" class="headerlink" title="（2）读取配置方法二（Environment）"></a>（2）读取配置方法二（Environment）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Enviroment env;  <span class="hljs-comment">//注入env对象，不要弄错包</span><br><br><span class="hljs-comment">//以下内容是写在函数体内</span><br>System.out.println(env.getProperty(<span class="hljs-string">&quot;person.name&quot;</span>));<br><br></code></pre></td></tr></table></figure><h5 id="（3）读取配置文件方法三（-ConfigurationProperties）"><a href="#（3）读取配置文件方法三（-ConfigurationProperties）" class="headerlink" title="（3）读取配置文件方法三（@ConfigurationProperties）"></a>（3）读取配置文件方法三（@ConfigurationProperties）</h5><p>注：yml文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8085</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">abc</span><br><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Yaoyao</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">21</span><br><span class="hljs-attr">address:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">beijing</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">shanghai</span><br></code></pre></td></tr></table></figure><p>1、第一步，新建一个person类，添加属性与yml对应。右键生成getter 和 setter，然后添加注解：@Component（让它被识别）和@ConfigurationProperties。此时如果生成一个Person对象叫person，再输出它的值，则输出的name值是abc，age读取不了因此输出默认值0.因此。导入@ConfigurationProperties时，要用这样的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;person&quot;)</span><br></code></pre></td></tr></table></figure><p>2、controller文件中注入一个Person对象，用@Autowired注解来注入。并打印。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">@Autowired</span><br><span class="hljs-keyword">private</span> Person person;<br><br>System.<span class="hljs-keyword">out</span>.println(person);<br></code></pre></td></tr></table></figure><p>我们会发现打印出来的结果是org.example.demo.Person@347d42b6，这是因为默认情况下会打印出对象的类名和对象的哈希码。如果想要打印出对象的具体属性值，则需要在Person类中重写toString（）方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时打印出来的结果就变成了Person{name&#x3D;’Yaoyao’, age&#x3D;21}</p><p>3、读取数组</p><p>1）将address数组复制到person下，在Person里加入字符串数组private String[] address</p><p>并在Person里加入getter 和 setter，不需重写toString。</p><p>2）controller文件中输入person.getaddress，alt+enter键快捷生成常量。接着打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] address = person.getAddress();<br>    <span class="hljs-keyword">for</span>(String s : address)&#123;<br>        System.out.println(s);<br>    &#125;<br></code></pre></td></tr></table></figure><p>控制台会打印出beijing和shanghai。</p><h4 id="4、profile"><a href="#4、profile" class="headerlink" title="4、profile"></a>4、profile</h4><p>我们在开发spring boot应用时，通常同一套程序会被安装到不同的环境，比如开发、测试、生产等。其中数据库地址、服务器端口等配置都不同，如果每次打包时都要修改配置文件则非常麻烦，profile就是用来进行动态配置切换的。</p><h5 id="（1）profile配置——多profile文件方式"><a href="#（1）profile配置——多profile文件方式" class="headerlink" title="（1）profile配置——多profile文件方式"></a>（1）profile配置——多profile文件方式</h5><p>创建多个properties文件，分别命名为application-dev.properties（开发）、application-test.properties（测试）、application-pro.properties（生产）。如果分别在里面设置了端口号，这时候直接运行，会显示Tomcat仍旧运行在默认端口8080，因为没有配置文件被激活。如果想要激活某一个配置文件，可以在主配置文件中加入<strong>spring.profiles.active&#x3D;dev</strong>；这时就激活了application-dev.properties</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240801175409410.png" alt="image-20240801175409410"></p><h5 id="（2）profile配置——yml多文档方式（更加简洁）"><a href="#（2）profile配置——yml多文档方式（更加简洁）" class="headerlink" title="（2）profile配置——yml多文档方式（更加简洁）"></a>（2）profile配置——yml多文档方式（更加简洁）</h5><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240801214745825.png" alt="image-20240801214745825" style="zoom:67%;" /><p>（需要把刚刚的那些配置注释掉）(记得空格，不要把server写成sever。。服了，找半天错误)</p><h5 id="（3）不依赖idea修改配置和激活工程"><a href="#（3）不依赖idea修改配置和激活工程" class="headerlink" title="（3）不依赖idea修改配置和激活工程"></a>（3）不依赖idea修改配置和激活工程</h5><p>右边找到package选项将工程打包成jar文件</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240801181439994.png" alt="image-20240801181439994" style="zoom: 67%;" /><p>找到文件位置打开终端，java -jar .\demo1-0.0.1-SNAPSHOT.jar运行。</p><p>如果想要在这里配置参数，java -jar .\demo1-0.0.1-SNAPSHOT.jar –spring.profiles.active&#x3D;test</p><h4 id="5、内外部配置文件加载顺序"><a href="#5、内外部配置文件加载顺序" class="headerlink" title="5、内外部配置文件加载顺序"></a>5、内外部配置文件加载顺序</h4><p>1）内部</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240803140132561.png" alt="image-20240803140132561" style="zoom:50%;" /><p>其中我们用的在resources目录下的properties配置文件属于第四种</p><p>2）外部</p><p>可以通过命令行的方式来修改配置。</p><p>方法一：在运行jar包语句后面加上 –server.port&#x3D;8053这样类似的配置语句</p><p>方法二：在运行jar包语句后面加上 –spring.config.location&#x3D;&#x2F;放置的外部配置文件的路径</p>]]></content>
    
    
    <categories>
      
      <category>xxx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-spring boot -java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过idea基于maven新建spring boot项目并运行（2024版本）</title>
    <link href="/2024/07/01/%E9%80%9A%E8%BF%87idea%E5%9F%BA%E4%BA%8Emaven%E6%96%B0%E5%BB%BAspring-boot%E9%A1%B9%E7%9B%AE%E5%B9%B6%E8%BF%90%E8%A1%8C%EF%BC%882024%E7%89%88%E6%9C%AC%EF%BC%89/"/>
    <url>/2024/07/01/%E9%80%9A%E8%BF%87idea%E5%9F%BA%E4%BA%8Emaven%E6%96%B0%E5%BB%BAspring-boot%E9%A1%B9%E7%9B%AE%E5%B9%B6%E8%BF%90%E8%A1%8C%EF%BC%882024%E7%89%88%E6%9C%AC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>此博客记录如何成功运行一个spring boot项目并用APIFOX进行测试。</p><span id="more"></span><p>运行项目运行了很久都是不报错但是加载不出界面的情况，一开始以为是版本不匹配的原因，后来发现其实不是！（现在安装了JDK22、17、11三个版本……已老实）目前IDEA版本是最新版2024.1.4，JDK是22版本，maven也是最新版。</p><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="1、首先需要配置JDK、maven两个软件"><a href="#1、首先需要配置JDK、maven两个软件" class="headerlink" title="1、首先需要配置JDK、maven两个软件"></a>1、首先需要配置JDK、maven两个软件</h4><h5 id="（1）下载软件"><a href="#（1）下载软件" class="headerlink" title="（1）下载软件"></a>（1）下载软件</h5><p>JDK：<a href="https://www.oracle.com/java/technologies/downloads/#jdk22-windows">https://www.oracle.com/java/technologies/downloads/#jdk22-windows</a></p><p>我一般会下载最新版（但是老版兼容性会更好一些）</p><p>maven：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>  下滑找到如图所示版本下载</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701104309249.png" alt="image-20240701104309249"></p><h5 id="（2）配置环境变量"><a href="#（2）配置环境变量" class="headerlink" title="（2）配置环境变量"></a>（2）配置环境变量</h5><p>在系统变量下添加如下所示两个环境变量，变量值是文件的地址（按照自己的文件地址添加）</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-01%20110538.png" alt="屏幕截图 2024-07-01 110538"></p><p>在系统变量中找到Path变量，点击编辑，在后面添加如下所示两条</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701110456636.png" alt="image-20240701110456636"></p><p>cmd打开终端，输入如下命令，出现如图所示的信息，显示了maven和JDK版本，说明配置成功。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">mvn -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701110615522.png" alt="image-20240701110615522"></p><h4 id="2、-下载IntelliJ-IDEA"><a href="#2、-下载IntelliJ-IDEA" class="headerlink" title="2、  下载IntelliJ IDEA"></a>2、  下载IntelliJ IDEA</h4><p>仍旧是去官网下载：<a href="https://www.jetbrains.com.cn/idea/download/?section=windows">下载 IntelliJ IDEA – 领先的 Java 和 Kotlin IDE (jetbrains.com.cn)</a></p><p>但是我们会发现这是收费的，于是只能去下载破解版。此处贴上我当时参考的链接：</p><p><a href="https://www.quanxiaoha.com/idea-pojie/idea-pojie-20241.html">IDEA 2024.1 最新激活码，破解版安装教程（亲测有效~） - 犬小哈教程 (quanxiaoha.com)</a></p><h3 id="二、开始创建项目"><a href="#二、开始创建项目" class="headerlink" title="二、开始创建项目"></a>二、开始创建项目</h3><p>我运行出来的结果是这样的：</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701144938865.png" alt="image-20240701144938865" style="zoom: 67%;" /><p>虽然很简单但是搞了一下午加一晚上……不知道为什么跟着教程或者GPT都弄不出来，总是各种报错……后来GPT突然活了，我调整了一下文件结构然后就成功了！！</p><h4 id="1、安装插件（可选）"><a href="#1、安装插件（可选）" class="headerlink" title="1、安装插件（可选）"></a>1、安装插件（可选）</h4><p>很多插件都是内置的，我只迷迷糊糊安装了一个wl spring assistant，也不知道有什么用。不过首先要安装的还是汉化包。按照我搜到的教程，应该是要安装Spring Initializr这个插件的，但是它需要Spring  boot helper这个插件才能正常工作。但是Spring  boot helper也需要购买，免费的老版本也需要老版本的idea才行。（在我激情卸载新版本下载老版本后，我发现老版本的破解帖子大多都失效了……）</p><h4 id="2、新建项目"><a href="#2、新建项目" class="headerlink" title="2、新建项目"></a>2、新建项目</h4><p>（1）如图，由于我没有下载Spring Initializr这个插件，所以我只能选择Spring Boot这个选项，和网上的教程都不一样（所以我才急切想下载过去的版本，但是失败了anyway）。</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701145920537.png" alt="image-20240701145920537" style="zoom: 50%;" /><p>但是当我最终放弃下载老版本，又灰溜溜把新版本装好后，把鼠标放在Spring Boot这个选项上面时，它显示了这样一句话。。。。（所以其实是一样的，好像没有什么不同！）</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701150249468.png" style="zoom: 80%;" /><p>（2）右边我选的就是这样，只改动了圈出的地方，最上面名称可以自己设置。</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701150551021.png" alt="image-20240701150551021" style="zoom: 67%;" /><p>（3）选择依赖项</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701150654448.png" alt="image-20240701150654448"><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701150713132.png" alt="image-20240701150713132"></p><p>由于这个项目比较简单所以就选择了这两个，暂时不需要数据库的依赖项。</p><p>然后项目就创建好了！</p><h3 id="三、配置项目"><a href="#三、配置项目" class="headerlink" title="三、配置项目"></a>三、配置项目</h3><p>进入项目后，把重要文件夹展开后是这样（刚新建项目没有target文件夹）</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701152318300.png" alt="image-20240701152318300" style="zoom:67%;" /><p>其实我不是很明白为什么会出现test文件夹（不管项目怎么命名都会出现，但是最开始是没有的……不知道是不是我按了什么不该按的）下面这两个文件是可以运行的。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701152517651.png" alt="image-20240701152517651"><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701152534710.png" alt="image-20240701152534710"></p><p>第一步：需要添加两个文件。右键下面任意一个软件包，选择添加一个java类，我命名为了helloController</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701152723798.png" alt="image-20240701152723798" style="zoom:67%;" /><p>在这个文件中添加如下代码（请看注释要点！不然会报错）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.test; <span class="hljs-comment">//注意test这个单词是要改成你的项目名字的</span><br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;  <span class="hljs-comment">//不用改</span><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;  <span class="hljs-comment">//不用改</span><br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">helloController</span> &#123;  <span class="hljs-comment">//这个类名要和刚刚创建的java类名一致</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">home</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>; <span class="hljs-comment">// 返回模板文件的名称，不需要扩展名</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后右键这个文件夹选择新建一个html文件，命名为index</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701153234536.png" alt="image-20240701153234536"></p><p>在文件中添加如下代码（body内添加内容，&lt; br&#x2F; &gt;是换行符）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>##################<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>  <br>############<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二步就可以点击运行了。但是此时可能会报错，如你的报错原因是如下图，那么应该是跟我一样，因为默认端口号8080已经被占用了。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701153703817.png" alt="image-20240701153703817"></p><p>解决方法也很简单，就是换个端口号，点开下面的文件，在其最上方添加一行代码server.port&#x3D;8016（可以自己改端口号）（当然也可以选择在管理员终端终止8080端口运行，但是还是改个端口更简单）</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701153818223.png" alt="image-20240701153818223" style="zoom:80%;" /><p>然后应该就能运行成功了！这时我们在电脑上访问localhost:8016（端口号），就可以看见我们在html中写的内容了。</p><h3 id="四、API测试"><a href="#四、API测试" class="headerlink" title="四、API测试"></a>四、API测试</h3><h4 id="1、在官网下载APIFox"><a href="#1、在官网下载APIFox" class="headerlink" title="1、在官网下载APIFox"></a>1、在官网下载APIFox</h4><p><a href="https://apifox.com/">https://apifox.com/</a></p><h4 id="2、创建一个新的项目"><a href="#2、创建一个新的项目" class="headerlink" title="2、创建一个新的项目"></a>2、创建一个新的项目</h4><p>项目类型选择html</p><h4 id="3、添加一个新的接口"><a href="#3、添加一个新的接口" class="headerlink" title="3、添加一个新的接口"></a>3、添加一个新的接口</h4><p>配置请求：</p><ul><li>请求方法：GET</li><li>请求 URL：&#96;<a href="http://localhost:8016‘">http://localhost:8016‘</a></li><li>添加查询参数：name（可选）</li><li>返回相应的内容格式选html</li></ul><h4 id="4、点击发送按钮查看响应"><a href="#4、点击发送按钮查看响应" class="headerlink" title="4、点击发送按钮查看响应"></a>4、点击发送按钮查看响应</h4><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701163121572.png" alt="image-20240701163121572"></p><h3 id="五、一些问题记录"><a href="#五、一些问题记录" class="headerlink" title="五、一些问题记录"></a>五、一些问题记录</h3><h4 id="1、依赖项thymeleaf的作用"><a href="#1、依赖项thymeleaf的作用" class="headerlink" title="1、依赖项thymeleaf的作用"></a>1、依赖项thymeleaf的作用</h4><p>将 Thymeleaf 集成到 Spring Boot 应用中，使得你可以使用 Thymeleaf 作为模板引擎来渲染 HTML 页面。</p><p>如果一开始新建项目时没有添加这个依赖项，也可以打开pom.xml文件中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、Controller文件的作用"><a href="#2、Controller文件的作用" class="headerlink" title="2、Controller文件的作用"></a>2、Controller文件的作用</h4><p>控制器（Controller）是用于处理 HTTP 请求的核心组件。控制器的主要职责是接收用户的输入，并根据该输入返回相应的响应。控制器通常与视图模板或 RESTful API 结合使用。</p><p>上面的helloController文件按理来说应该命名为HomeController，表示端口号域名不加任何后续路径，处理根路径’ &#x2F; ‘并返回index.html模板。</p><p>然后我们还可以新建一个HelloController文件，用于处理 ’ hello ‘ 路径并返回一个简单的字符串响应。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.demoa;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span>      <span class="hljs-comment">//RESTful控制器，返回JSON数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>  <span class="hljs-comment">//括号里是路径</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Hello, %s!&quot;</span>, name);  <span class="hljs-comment">//返回Hello World！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>xxx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>java</tag>
      
      <tag>maven</tag>
      
      <tag>IntelliJ IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置服务器记录</title>
    <link href="/2024/06/29/%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/29/%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>在阿里云平台免费领取了七个月服务器使用权，在这里记录一下配置经过。</p><span id="more"></span><h3 id="一、服务器"><a href="#一、服务器" class="headerlink" title="一、服务器"></a>一、服务器</h3><h4 id="1、云服务器的使用流程"><a href="#1、云服务器的使用流程" class="headerlink" title="1、云服务器的使用流程"></a>1、云服务器的使用流程</h4><p>（1）<strong>获取</strong>云服务器ECS——登录<a href="http://www.aliyun.com,购买或免费领用云服务器ecs/">www.aliyun.com，购买或免费领用云服务器ECS</a></p><p>（2）<strong>登录</strong>云服务器ECS——远程登录ECS实例配置主机环境</p><p>（3）<strong>管理</strong>云服务器ECS——在云服务器上搭建个人网站，管理并维护网站</p><p>（4）<strong>释放</strong>云服务器ECS——不需要ECS实例时释放资源，节省费用</p><h4 id="2、登录云服务器-windows系统"><a href="#2、登录云服务器-windows系统" class="headerlink" title="2、登录云服务器(windows系统)"></a>2、登录云服务器(windows系统)</h4><p>（1）点击远程管理之后点击立即登录，进入以下界面，第一次登陆的时候需要设置密码，需要记住这个密码。确定后就登陆上了这个服务器；</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701100745300.png" alt="image-20240701100745300" style="zoom: 50%;" /><p>（2）我一般在电脑终端进行登录，cmd打开终端，输入以下语句登录；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh <span class="hljs-symbol">root@</span>公网IP<br></code></pre></td></tr></table></figure><p>出现以下界面，说明登陆成功，现在可以在服务器中进行配置了。</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240701101436004.png" alt="image-20240701101436004" style="zoom:50%;" /><h3 id="二、配置MySQL"><a href="#二、配置MySQL" class="headerlink" title="二、配置MySQL"></a>二、配置MySQL</h3>]]></content>
    
    
    <categories>
      
      <category>从零写一款APP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>ECS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题记录（不分类版）</title>
    <link href="/2024/05/24/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%8D%E5%88%86%E7%B1%BB%E7%89%88%EF%BC%89/"/>
    <url>/2024/05/24/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%8D%E5%88%86%E7%B1%BB%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>尽量保证每天至少做两题，保持手感。累计11题。</p><span id="more"></span><h3 id="2024-5-24"><a href="#2024-5-24" class="headerlink" title="2024&#x2F;5&#x2F;24"></a>2024&#x2F;5&#x2F;24</h3><h4 id="（1）接雨水"><a href="#（1）接雨水" class="headerlink" title="（1）接雨水"></a>（1）接雨水</h4><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p><p>记得第一次看到这题，两眼一黑就没管了。昨晚睡觉时突然想到，想了半天，今天写的时候也没写出来。总结错误原因是：1、想到了要记录左边最大值和右边最大值，但是记录的非常笨拙；2、记录的最大值不是真的最大值，而是每个凹陷两边的最大值。还是题感不够以及思路不够灵活。刚好这道题用到的很多方法是我不会的，遂记录。</p><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>（已超时）分别记录高度为1、2、3……等这一行能接多少雨水。需要遍历两层，记录当前列的左边和右边是否有值，若有则这一块可以接到雨水。时间复杂度O(n2);</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>动态规划：1、用两个数组leftmax[]和rightmax[]分别记录某个位置左边高度的最大值和右边高度的最大值。两个最大值中小的那个减去它的高度就是这一列能接到的雨水量；2、如何得到两个数组的值？（动态规划）leftmax[0]&#x3D;h[0]，rightmax[n-1]&#x3D;h[n-1]。从左向右遍历，得到等式：left[ i ]&#x3D;max( left[ i-1],h[ i] ) , 从右向左遍历，得到right[i]&#x3D;max(right[ i+1],h[ i ])；</p><p>时间复杂度：O（n），空间复杂度：O（n）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> left[<span class="hljs-number">20004</span>],right[<span class="hljs-number">20004</span>];  <br><span class="hljs-type">int</span> cnt,tmp;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n=h.<span class="hljs-built_in">size</span>();<br>   left[<span class="hljs-number">0</span>]=h[<span class="hljs-number">0</span>],right[n<span class="hljs-number">-1</span>]=h[n<span class="hljs-number">-1</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>      left[i]=<span class="hljs-built_in">max</span>(left[i<span class="hljs-number">-1</span>],h[i]);<br>      right[n-i<span class="hljs-number">-1</span>]=<span class="hljs-built_in">max</span>(right[n-i],h[i]);<br>   &#125;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>      tmp=<span class="hljs-built_in">min</span>(left[i],right[i]);<br>      cnt+=tmp-h[i];<br>   &#125;<br>   <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><p>单调栈：单调栈内存储的是下标。如果该下标高度小于栈顶，入栈；否则开始计算两个下标之间可以接的雨水量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> cnt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>   stack&lt;<span class="hljs-type">int</span>&gt; r;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;h,<span class="hljs-built_in">size</span>();i++)&#123;<br>      <span class="hljs-keyword">while</span>(!r.<span class="hljs-built_in">empty</span>()&amp;&amp;h[r.<span class="hljs-built_in">top</span>()]&lt;h[i])&#123;<br>         <span class="hljs-type">int</span> cur=t.<span class="hljs-built_in">top</span>();<br>         r.<span class="hljs-built_in">pop</span>();<br>         <span class="hljs-keyword">if</span>(r.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">break</span>;<br>         cnt+=(<span class="hljs-built_in">min</span>(h[r.<span class="hljs-built_in">top</span>()],h[i])-h[cur])*(i-r.<span class="hljs-built_in">top</span>()<span class="hljs-number">-1</span>);<br>      &#125;<br>      r.<span class="hljs-built_in">push</span>(i);<br>   &#125;<br>   <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2024-5-28"><a href="#2024-5-28" class="headerlink" title="2024&#x2F;5&#x2F;28"></a>2024&#x2F;5&#x2F;28</h3><h4 id="（1）合并两个有序数组（字符串、数组）"><a href="#（1）合并两个有序数组（字符串、数组）" class="headerlink" title="（1）合并两个有序数组（字符串、数组）"></a>（1）合并两个有序数组（字符串、数组）</h4><p><a href="https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">88. 合并两个有序数组 - 力扣（LeetCode）</a></p><h5 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h5><p>直接合并然后排序（时间复杂度O(m+n)log(m+n)）</p><h5 id="方法二：-1"><a href="#方法二：-1" class="headerlink" title="方法二："></a>方法二：</h5><p>逆序双指针：m、n分别指向两个数组最后一个（不是0的）元素，然后每次作比较，将大的数字放在数组的最后一个位置，相应指针和位置前移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br> <span class="hljs-type">int</span> i=m+n<span class="hljs-number">-1</span>;<br>   <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">if</span>(m&gt;<span class="hljs-number">0</span>&amp;&amp;nums1[m<span class="hljs-number">-1</span>]&gt;nums2[n<span class="hljs-number">-1</span>])&#123;<br>         nums1[i--]=nums2[m<span class="hljs-number">-1</span>];<br>         m--;<br>      &#125;<br>      <span class="hljs-keyword">else</span>&#123;<br>nums1[i--]=nums2[n<span class="hljs-number">-1</span>];<br>         n--;         <br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2024-5-29"><a href="#2024-5-29" class="headerlink" title="2024&#x2F;5&#x2F;29"></a>2024&#x2F;5&#x2F;29</h3><h4 id="（1）长度最小的子数组（二分、前缀和、滑动窗口）"><a href="#（1）长度最小的子数组（二分、前缀和、滑动窗口）" class="headerlink" title="（1）长度最小的子数组（二分、前缀和、滑动窗口）"></a>（1）长度最小的子数组（二分、前缀和、滑动窗口）</h4><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><h5 id="方法一：暴力法（超时）"><a href="#方法一：暴力法（超时）" class="headerlink" title="方法一：暴力法（超时）"></a>方法一：暴力法（超时）</h5><h5 id="方法二：-2"><a href="#方法二：-2" class="headerlink" title="方法二："></a>方法二：</h5><p>前缀和+二分查找：在想到使用前缀和之后，需要使用二分查找找到想要的下标才能使时间复杂度下降。而在每个语言中都已经有内置的二分查找函数，找到大于或者等于某个数的第一个位置。c++：lower_bound。时间复杂度：nlog(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> ans=INT_MAX;   <span class="hljs-comment">//表示最大的整数，在后面的比较时有用</span><br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;   <span class="hljs-comment">//sum[i]存储的是nums[0]到nums[i-1]的和，因此要设置n+1的长度，sum[0]=0,sum[1]=nums[0]……</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      sum[i]=sum[i<span class="hljs-number">-1</span>]+nums[i];   <span class="hljs-comment">//计算前缀和</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>      <span class="hljs-type">int</span> s=target+sum[i<span class="hljs-number">-1</span>];   <span class="hljs-comment">//将目标加上当前坐标的前缀和，方便查找（i-1为子串第一个坐标）</span><br>      <span class="hljs-keyword">auto</span> bound=<span class="hljs-built_in">lower_bound</span>(sum.<span class="hljs-built_in">begin</span>(),sum.<span class="hljs-built_in">end</span>(),s);  <span class="hljs-comment">//注意查找得到的是位置</span><br>      <span class="hljs-keyword">if</span>(bound!=sum.<span class="hljs-built_in">end</span>())<br>         ans=<span class="hljs-built_in">min</span>(ans,bound-sum.<span class="hljs-built_in">begin</span>()-(i<span class="hljs-number">-1</span>));  <br>   &#125;<br>   <span class="hljs-keyword">return</span> ans==INT_MAX?<span class="hljs-number">0</span>:ans;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法三：-1"><a href="#方法三：-1" class="headerlink" title="方法三："></a>方法三：</h5><p>滑动窗口：设置左右指针表示窗口的两边，保证窗口内元素之和满足要求时，左指针右移，不断保存左右指针相差最小的那个值。当窗口不符合要求时，右指针继续右移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">int</span> target,vetor&lt;<span class="hljs-type">int</span>&gt; num)</span></span>&#123;<br>   <span class="hljs-type">int</span> n=num.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">if</span>(!n)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> ans=INT_MAX,l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(r&lt;n)&#123;<br>      sum+=num[r];<br>      <span class="hljs-keyword">while</span>(sum&gt;=target)&#123;<br>         ans=<span class="hljs-built_in">min</span>(ans,r-l+<span class="hljs-number">1</span>);<br>         sum-=num[l];<br>         l++;<br>      &#125;<br>      r++;<br>   &#125;<br>   <span class="hljs-keyword">return</span> ans==INT_MAX?<span class="hljs-number">0</span>:ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）搜索二维矩阵（二分法）"><a href="#（2）搜索二维矩阵（二分法）" class="headerlink" title="（2）搜索二维矩阵（二分法）"></a>（2）搜索二维矩阵（二分法）</h4><h5 id="方法一：两次二分查找"><a href="#方法一：两次二分查找" class="headerlink" title="方法一：两次二分查找"></a>方法一：两次二分查找</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; num, <span class="hljs-type">int</span> t)</span> </span>&#123;<br><span class="hljs-keyword">auto</span> row=<span class="hljs-built_in">upper_bound</span>(num.<span class="hljs-built_in">begin</span>(),num.<span class="hljs-built_in">end</span>(),t,[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> b,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)&#123;<span class="hljs-keyword">return</span> b&lt;a[<span class="hljs-number">0</span>];&#125;);  <span class="hljs-comment">//找到第一个元素大于给定元素的那一行</span><br>   <span class="hljs-keyword">if</span>(row==num.<span class="hljs-built_in">begin</span>())  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   --row;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(row-&gt;<span class="hljs-built_in">begin</span>(),row-&gt;<span class="hljs-built_in">end</span>(),t);<br>   <span class="hljs-comment">//二分查找函数，找到等于给定元素的下标，找不到就返回false</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法二：一次二分查找（假想成一维数组）"><a href="#方法二：一次二分查找（假想成一维数组）" class="headerlink" title="方法二：一次二分查找（假想成一维数组）"></a>方法二：一次二分查找（假想成一维数组）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; num, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>   <span class="hljs-type">int</span> m=num.<span class="hljs-built_in">size</span>(),n=num[<span class="hljs-number">0</span>].size;   <span class="hljs-comment">//得到行数(m)和列数(n)</span><br>   <span class="hljs-type">int</span> low=<span class="hljs-number">0</span>,high=m*n<span class="hljs-number">-1</span>;<br>   <span class="hljs-keyword">while</span>(low&lt;high)&#123;<br>      <span class="hljs-type">int</span> mid=(high-low)/<span class="hljs-number">2</span>+low;  <span class="hljs-comment">//防止溢出</span><br>      <span class="hljs-type">int</span> x=num[mid/n][mid%n];   <span class="hljs-comment">//注意是n！！！不是m</span><br>      <span class="hljs-keyword">if</span>(x&lt;t)<br>         low=mid+<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;t)<br>         high=mid<span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">else</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）打家劫舍（一维动态规划）"><a href="#（3）打家劫舍（一维动态规划）" class="headerlink" title="（3）打家劫舍（一维动态规划）"></a>（3）打家劫舍（一维动态规划）</h4><p><a href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-interview-150">198. 打家劫舍 - 力扣（LeetCode）</a></p><p>第一步：定义子问题：从k间房屋中可以偷到的最大金额</p><p>第二步：列出递推关系。题目要求不能够偷两间相邻的房屋，因此偷k间房屋就有了两个选择，f[k]&#x3D;max( f[k-1] , f[k-2]+num[k-1] )；</p><p>第三步：写出已知值。f[0]&#x3D;0,f[1]&#x3D;num[0];</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; num)</span></span>&#123;<br>   <span class="hljs-type">int</span> n=num.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">if</span>(!n)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>   add[<span class="hljs-number">1</span>]=num[<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>      add[i+<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(add[i],add[i<span class="hljs-number">-1</span>]+num[i]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> add[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>第四步：空间优化。我们发现每次都只需要用到数组的最后两个值，因此用两个整数保存这两个值即可，不需要多余空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; num)</span></span>&#123;<br>   <span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>,cur=<span class="hljs-number">0</span>,ans;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:num)&#123;<br>      ans=<span class="hljs-built_in">max</span>(pre+i,cur);<br>      pre=cur;<br>      cur=ans;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）三角形最小路径和（二维动态规划）"><a href="#（4）三角形最小路径和（二维动态规划）" class="headerlink" title="（4）三角形最小路径和（二维动态规划）"></a>（4）三角形最小路径和（二维动态规划）</h4><p><a href="https://leetcode.cn/problems/triangle/description/?envType=study-plan-v2&envId=top-interview-150">120. 三角形最小路径和 - 力扣（LeetCode）</a></p><h5 id="方法一：动态规划（自底向上）-不改动原数组"><a href="#方法一：动态规划（自底向上）-不改动原数组" class="headerlink" title="方法一：动态规划（自底向上）(不改动原数组)"></a>方法一：动态规划（自底向上）(不改动原数组)</h5><p>设dp[i] [j]表示第i行第j个元素到最后一行的最短路径，则可以得到状态转移方程：                      dp[i] [j]&#x3D;min(dp[i+1] [j] , dp[i+1] [j+1]) +triangle[i] [j]，则dp[0] [0]为所需值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n=triangle.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-type">int</span>[][] dp=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>         dp[i][j]=<span class="hljs-built_in">min</span>(dp[i+j][j],dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])+triangle[i][j];<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法二：动态规划（空间优化）"><a href="#方法二：动态规划（空间优化）" class="headerlink" title="方法二：动态规划（空间优化）"></a>方法二：动态规划（空间优化）</h5><p>我们会发现每次只需要用到两个先前值，因此不需要用到二维数组。dp数组不断保存每一行每个值遍历到最后一行的最短路径之和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n=triangle.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-type">int</span>[] dp=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n+<span class="hljs-number">1</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>         dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j+<span class="hljs-number">1</span>])+triangle[i][j];<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2024-5-30"><a href="#2024-5-30" class="headerlink" title="2024&#x2F;5&#x2F;30"></a>2024&#x2F;5&#x2F;30</h3><h4 id="（1）最小路径和（二维动态规划）"><a href="#（1）最小路径和（二维动态规划）" class="headerlink" title="（1）最小路径和（二维动态规划）"></a>（1）最小路径和（二维动态规划）</h4><p><a href="https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150">64. 最小路径和 - 力扣（LeetCode）</a></p><p>跟昨天做的题思路很像（相当于偷个小懒hhh），也是丝滑地ac了，就是没有空间优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>(),n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br>        dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]=grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>            dp[i][n<span class="hljs-number">-1</span>]=dp[i+<span class="hljs-number">1</span>][n<span class="hljs-number">-1</span>]+grid[i][n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>            dp[m<span class="hljs-number">-1</span>][i]=dp[m<span class="hljs-number">-1</span>][i+<span class="hljs-number">1</span>]+grid[m<span class="hljs-number">-1</span>][i];  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-2</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                dp[i][j]=<span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i][j+<span class="hljs-number">1</span>])+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>试着空间优化一下：(分类讨论地好狗屎，但是不知道怎么分情况更简单了。。。)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>   <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>(),n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>   dp[<span class="hljs-number">0</span>]=grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>         <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>&amp;&amp;j!=<span class="hljs-number">0</span>)<br>            dp[j]=dp[j<span class="hljs-number">-1</span>]+grid[i][j];<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>&amp;&amp;i!=<span class="hljs-number">0</span>)<br>            dp[j]=dp[j]+grid[i][j];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>&amp;&amp;j!=<span class="hljs-number">0</span>)<br>            dp[j]=<span class="hljs-built_in">min</span>(dp[j<span class="hljs-number">-1</span>],dp[j])+grid[i][j];<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）不同路径（二维动规、障碍物）"><a href="#（2）不同路径（二维动规、障碍物）" class="headerlink" title="（2）不同路径（二维动规、障碍物）"></a>（2）不同路径（二维动规、障碍物）</h4><p><a href="https://leetcode.cn/problems/unique-paths-ii/description/?envType=study-plan-v2&envId=top-interview-150">63. 不同路径 II - 力扣（LeetCode）</a></p><h5 id="方法一：动规数组存储该位置的路径和，遇到障碍物该位置路径数变为零。"><a href="#方法一：动规数组存储该位置的路径和，遇到障碍物该位置路径数变为零。" class="headerlink" title="方法一：动规数组存储该位置的路径和，遇到障碍物该位置路径数变为零。"></a>方法一：动规数组存储该位置的路径和，遇到障碍物该位置路径数变为零。</h5><p>AC，但是空间复杂度有点高，而且在初始化的时候容易犯错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br><span class="hljs-type">int</span> m=obstacleGrid.<span class="hljs-built_in">size</span>(),n=obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>   <span class="hljs-type">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br>   dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)<br>      dp[i][<span class="hljs-number">0</span>]=dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>      dp[<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>         <span class="hljs-keyword">if</span>(obstacleGrid[i][j])<br>            dp[i][j]=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">else</span><br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法二：空间优化（滚动数组）"><a href="#方法二：空间优化（滚动数组）" class="headerlink" title="方法二：空间优化（滚动数组）"></a>方法二：空间优化（滚动数组）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>   <span class="hljs-type">int</span> m=obstacleGrid.<span class="hljs-built_in">size</span>(),n=obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>   dp[<span class="hljs-number">0</span>]=obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>         <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>            dp[j]=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>)<br>            dp[j]+=dp[j<span class="hljs-number">-1</span>];<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）最长回文子串"><a href="#（3）最长回文子串" class="headerlink" title="（3）最长回文子串"></a>（3）最长回文子串</h4><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-interview-150">5. 最长回文子串 - 力扣（LeetCode）</a></p><h5 id="方法一：中心扩展法"><a href="#方法一：中心扩展法" class="headerlink" title="方法一：中心扩展法"></a>方法一：中心扩展法</h5><p>分为两种情况：1、回文串长度是奇数；2、回文串长度是偶数。因此从中心向外扩展时也就有两种情况：1、中心是当前值；2、中心是当前值与右边值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">size</span>(),pre=<span class="hljs-number">0</span>,maxL=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>      <span class="hljs-type">int</span> l=i<span class="hljs-number">-1</span>,r=i;<br>      <span class="hljs-keyword">for</span>(;l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r];l--,r++);<br>      <span class="hljs-keyword">if</span>(maxL&lt;r-l+<span class="hljs-number">1</span>)&#123;<br>         maxL=r-l+<span class="hljs-number">1</span>;<br>         pre=l+<span class="hljs-number">1</span>;<br>      &#125;<br>      l=i<span class="hljs-number">-1</span>,r=i+<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(;l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r];l--,r++);<br>      <span class="hljs-keyword">if</span>(maxL&lt;r-l+<span class="hljs-number">1</span>)&#123;<br>         maxL=r-l+<span class="hljs-number">1</span>;<br>         pre=l+<span class="hljs-number">1</span>;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(pre,maxL);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h4><p>不知道为什么力扣不能完全通过……不理解</p><p>理解了，因为没有初始化为false啊啊啊啊我要气死了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录左右边界和右-左的长度</span><br>    <span class="hljs-type">bool</span> dp[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;len;j++)&#123;<span class="hljs-comment">//j=i这步就将每个单个字符dp赋为了true</span><br>            <span class="hljs-keyword">if</span>(s[i]==s[j]&amp;&amp;(j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]))&#123;<br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(j-i&gt;res)&#123;<br>                    res=j-i;<span class="hljs-comment">//res记得也得更新！</span><br>                    left=i;<br>                    right=j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(left,res+<span class="hljs-number">1</span>);<span class="hljs-comment">//左闭右开</span><br>&#125; <br></code></pre></td></tr></table></figure><h4 id="（4）删除有序数组中的重复项-II（双指针）"><a href="#（4）删除有序数组中的重复项-II（双指针）" class="headerlink" title="（4）删除有序数组中的重复项 II（双指针）"></a>（4）删除有序数组中的重复项 II（双指针）</h4><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></p><h5 id="方法一：双指针（？）"><a href="#方法一：双指针（？）" class="headerlink" title="方法一：双指针（？）"></a>方法一：双指针（？）</h5><p>自己写的，有点丑陋……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-type">int</span> j=i+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;nums.<span class="hljs-built_in">size</span>()&amp;&amp;nums[i]==nums[i+<span class="hljs-number">1</span>]&amp;&amp;nums[i]==nums[j])&#123;<br>                nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>()+j);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[i+<span class="hljs-number">1</span>])<br>                i+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span><br>                i+=<span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();       <br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="方法二：单指针"><a href="#方法二：单指针" class="headerlink" title="方法二：单指针"></a>方法二：单指针</h5><p>首先，定义一个指针 <code>i</code>，用来记录不重复元素的位置。</p><p>遍历数组 <code>nums</code>，对于数组中的每个元素 <code>num</code>：</p><ul><li>如果 <code>i</code> 小于 2（即数组前两个元素），或者当前元素 <code>num</code> 大于 <code>nums[i - 2]</code>（说明当前元素和前两个元素不相同），则将当前元素 <code>num</code> 赋值给 <code>nums[i]</code>，并将指针 <code>i</code> 向后移动一位，相当于将当前元素保留下来。</li><li>如果当前元素 <code>num</code> 和 <code>nums[i - 2]</code> 相同（说明当前元素已经重复出现两次以上），则不做任何操作，直接继续遍历下一个元素。</li></ul><p>最后返回指针 <code>i</code>，即为删除重复元素后数组的新长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>           <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">2</span> || num &gt; nums[i - <span class="hljs-number">2</span>]) &#123;<br>               nums[i++] = num;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> i;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）买卖股票的最佳时机"><a href="#（5）买卖股票的最佳时机" class="headerlink" title="（5）买卖股票的最佳时机"></a>（5）买卖股票的最佳时机</h4><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></p><p>自己写的代码太丑陋了而且还有bug（不知道为啥），这是chatgpt写的，跟我一样的思路怎么就这么简洁呢呃呃呃，怎么不算天才呢</p><p>我用了两个数组去记录……左边最小值和右边最大值，怎么不算愚蠢呢……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> minPrice = INT_MAX;<br>    <span class="hljs-type">int</span> maxProfit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>        minPrice = <span class="hljs-built_in">min</span>(minPrice, price);   <span class="hljs-comment">//记录到目前位置的股票价格最小值</span><br>        maxProfit = <span class="hljs-built_in">max</span>(maxProfit, price - minPrice);  <span class="hljs-comment">//维护利润最大值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> maxProfit;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2024-5-31"><a href="#2024-5-31" class="headerlink" title="2024&#x2F;5&#x2F;31"></a>2024&#x2F;5&#x2F;31</h3><h4 id="（1）买卖股票的最佳时机-（动规、贪心）"><a href="#（1）买卖股票的最佳时机-（动规、贪心）" class="headerlink" title="（1）买卖股票的最佳时机||（动规、贪心）"></a>（1）买卖股票的最佳时机||（动规、贪心）</h4><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/?envType=study-plan-v2&envId=top-interview-150">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p><h5 id="方法一：直接求解-贪心"><a href="#方法一：直接求解-贪心" class="headerlink" title="方法一：直接求解&#x2F;贪心"></a>方法一：直接求解&#x2F;贪心</h5><p>按照直接求解的思路，如果要使利润最大化，只需要把股票价格看成折线图，计算每一次上升的利润。如果把距离看为1，就看每两天是否有利润，只要有就增加利润值。</p><p>按照贪心的思路，由于股票的购买没有限制，因此相当于找到若干个不相交的区间，使区间内利润和最大。如果区间长度为1，也就等同于了刚刚的思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><span class="hljs-type">int</span> maxp=<span class="hljs-number">0</span>,n=prices.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>     maxp+=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,prices[i+<span class="hljs-number">1</span>]-prices[i]);  <span class="hljs-comment">//省去了每次判断两个股票值的大小</span><br>   <span class="hljs-keyword">return</span> maxp;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法二：动态规划-1"><a href="#方法二：动态规划-1" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h5><p>虽然知道可以动态规划但是就是想不到怎么规划！！！</p><p>首先要设置状态，可以设置dp[i] [0]表示第i天交易完时手里没有股票的最大利润，dp[i] [1]则表示手里有股票。下面就可以列状态转移方程。（一开始真的想复杂了，所以完全不知道这怎么转移）对于dp[i] [0]，有两种情况：1、dp[i] [0]&#x3D;dp[i-1] [0]（和前一天保持一致）                              2、dp[i] [0]&#x3D;dp[i-1] [1]+prices[i]（前一天有股票，今天卖出，获得今天的收益，不用管成本）对于dp[i] [1]：1、dp[i] [1]&#x3D;dp[i-1] [1]；2、dp[i] [1]&#x3D;dp[i-1] [0]-prices[i]</p><p>遍历结束后，我们手中有两个值，dp[n-1] [0]和dp[n-1] [1]，显然最后手里没有股票的话利润才是最大的，因此应该返回dp[n-1] [0]。</p><p>对于这道题也可以空间优化，因为每次都只是用到了前一天的两个值而已。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>(),dp0,dp1,newdp0,newdp1;<br>   dp0=<span class="hljs-number">0</span>,dp1=-prices[<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>      newdp0=<span class="hljs-built_in">max</span>(dp0,dp1+prices[i]);<br>      newdp1=<span class="hljs-built_in">max</span>(dp1,dp0-prices[i]);<br>      dp0=newdp0;<br>      dp1=newdp1;<br>   &#125;<br>   <span class="hljs-keyword">return</span> dp0;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）三数之和（双指针）"><a href="#（2）三数之和（双指针）" class="headerlink" title="（2）三数之和（双指针）"></a>（2）三数之和（双指针）</h4><p><a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-interview-150">15. 三数之和 - 力扣（LeetCode）</a></p><h5 id="方法一-自己写的（我也想写双指针法？？）"><a href="#方法一-自己写的（我也想写双指针法？？）" class="headerlink" title="方法一:自己写的（我也想写双指针法？？）"></a>方法一:自己写的（我也想写双指针法？？）</h5><p>通过了308&#x2F;313个用例呜呜呜我哭死。最后是时间超了，我的代码好丑陋……感觉超时间应该是因为用到了查找函数，有点丑陋。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>(),cur;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; num;<br>     <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>||nums[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>||nums[n<span class="hljs-number">-1</span>]&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> num;<br>        vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-2</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]=nums[i+<span class="hljs-number">1</span>])<br>              <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n<span class="hljs-number">-1</span>;j++)&#123;<br>                cur=nums[i]+nums[j];<br>                cur=<span class="hljs-number">0</span>-cur;<br>                <span class="hljs-keyword">auto</span> it=<span class="hljs-built_in">find</span>(nums.<span class="hljs-built_in">begin</span>()+j+<span class="hljs-number">1</span>,nums.<span class="hljs-built_in">end</span>(),cur);<br>                <span class="hljs-keyword">if</span>(it!=nums.<span class="hljs-built_in">end</span>())&#123;<br>                    tmp=&#123;nums[i],nums[j],nums[it-nums.<span class="hljs-built_in">begin</span>()]&#125;;<br>                    <span class="hljs-keyword">if</span>(num.<span class="hljs-built_in">empty</span>()||<span class="hljs-built_in">find</span>(num.<span class="hljs-built_in">begin</span>(),num.<span class="hljs-built_in">end</span>(),tmp)==num.<span class="hljs-built_in">end</span>())<br>                    num.<span class="hljs-built_in">push_back</span>(tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="方法二：（相向）双指针法"><a href="#方法二：（相向）双指针法" class="headerlink" title="方法二：（相向）双指针法"></a>方法二：（相向）双指针法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>   <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">//第一步排序</span><br>   vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; num;    <br>   <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">//我好不容易严谨一会上来就判断n是不是小于3，结果题目写了n&gt;=3</span><br>   <span class="hljs-keyword">if</span>(nums[n<span class="hljs-number">-1</span>]+num[n<span class="hljs-number">-2</span>]+nums[n<span class="hljs-number">-3</span>]&lt;<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> num;   <span class="hljs-comment">//最大三数和都小于0了</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-2</span>;i++)&#123;<br>      <span class="hljs-type">int</span> x=nums[i];<br>      <span class="hljs-keyword">if</span>(i&amp;&amp;x=nums[i<span class="hljs-number">-1</span>])   <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//跳过重复元素</span><br>      <span class="hljs-keyword">if</span>(nums[i]+num[i+<span class="hljs-number">1</span>]+nums[i+<span class="hljs-number">2</span>]&gt;<span class="hljs-number">0</span>)   <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//三数之和已经大于0</span><br>      <span class="hljs-keyword">if</span>(nums[n<span class="hljs-number">-1</span>]+num[n<span class="hljs-number">-2</span>]+nums[i]&lt;<span class="hljs-number">0</span>)   <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//和最大两个数相加都大于0</span><br>      <span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>,k=n<span class="hljs-number">-1</span>;   <span class="hljs-comment">//一前一后两个指针</span><br>      <span class="hljs-keyword">while</span>(j&lt;k)&#123;<br>         <span class="hljs-type">int</span> t=x+nums[j]+nums[k];<br>         <span class="hljs-keyword">if</span>(t&gt;<span class="hljs-number">0</span>)  k--;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>)  s--;<br>         <span class="hljs-keyword">else</span>&#123;<br>            num.push_back&#123;x,nums[j],nums[k]&#125;;<br>            <span class="hljs-keyword">for</span>(++j;j&lt;k&amp;&amp;nums[j]==nums[j<span class="hljs-number">-1</span>];++j);<br>            <span class="hljs-keyword">for</span>(--k;j&lt;k&amp;&amp;nums[k]==nums[k+<span class="hljs-number">1</span>];--k);  <span class="hljs-comment">//跳过重复的数字</span><br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）买卖股票的最佳时机-（k次）-动态规划"><a href="#（3）买卖股票的最佳时机-（k次）-动态规划" class="headerlink" title="（3）买卖股票的最佳时机|||（k次）(动态规划)"></a>（3）买卖股票的最佳时机|||（k次）(动态规划)</h4><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p><p>我是真的没有想到还有|||……后面好像还有IV。今天下午都要买卖股票啦，哈哈哈（苦笑）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=INT_MIN/<span class="hljs-number">2</span>;  <span class="hljs-comment">//除以二是为了防止溢出</span><br>   <span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-type">int</span> buy1=inf; <span class="hljs-comment">//第一次买后的最大收益，初始值设置为最低</span><br>   <span class="hljs-type">int</span> sell1=<span class="hljs-number">0</span>;  <span class="hljs-comment">//第一次卖掉后的最大收益</span><br>   <span class="hljs-type">int</span> buy2=inf;<br>   <span class="hljs-type">int</span> sell2=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;  <span class="hljs-comment">//变量更新的顺序可以随意调换</span><br>      sell1=<span class="hljs-built_in">max</span>(sell1,buy1+prices[i]);<br>      buy1=<span class="hljs-built_in">max</span>(buy1,-prices[i]);<br>      sell2=<span class="hljs-built_in">max</span>(sell2,buy2+prices[i]);<br>      buy2=<span class="hljs-built_in">max</span>(buy2,sell1-prices[i]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> sell2;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）买卖股票的最佳时期（k次）"><a href="#（4）买卖股票的最佳时期（k次）" class="headerlink" title="（4）买卖股票的最佳时期（k次）"></a>（4）买卖股票的最佳时期（k次）</h4><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/?envType=study-plan-v2&envId=top-interview-150">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>   k=<span class="hljs-built_in">min</span>(k,n/<span class="hljs-number">2</span>);<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buy</span><span class="hljs-params">(k+<span class="hljs-number">1</span>)</span></span>;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sell</span><span class="hljs-params">(k+<span class="hljs-number">1</span>)</span></span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>      buy[i]=INT_MIN/<span class="hljs-number">2</span>;<br>      sell[i]=<span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>         buy[j]=<span class="hljs-built_in">max</span>(buy[j],sell[j<span class="hljs-number">-1</span>]-prices[i]);<br>         sell[j]=<span class="hljs-built_in">max</span>(sell[j],buy[j<span class="hljs-number">-1</span>]+prices[i]);<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> sell[k];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）阶乘后的0（数学）"><a href="#（5）阶乘后的0（数学）" class="headerlink" title="（5）阶乘后的0（数学）"></a>（5）阶乘后的0（数学）</h4><p><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/description/?envType=study-plan-v2&envId=top-interview-150">172. 阶乘后的零 - 力扣（LeetCode）</a></p><p>这居然是中等？？你的中等我的中等好像不一样？？自己ac了但是贴个复杂度更小的解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>   <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(n)&#123;<br>      n=n/<span class="hljs-number">5</span>;<br>      ans+=n;<br>   &#125;<br>   <span class="hljs-keyword">return</span> ans;  <span class="hljs-comment">//就是~这么简单</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2024-6-1"><a href="#2024-6-1" class="headerlink" title="2024&#x2F;6&#x2F;1"></a>2024&#x2F;6&#x2F;1</h2><p>休息一天。。头疼</p><h3 id="2024-6-2"><a href="#2024-6-2" class="headerlink" title="2024&#x2F;6&#x2F;2"></a>2024&#x2F;6&#x2F;2</h3><h4 id="（1）直线上最多的点数"><a href="#（1）直线上最多的点数" class="headerlink" title="（1）直线上最多的点数"></a>（1）直线上最多的点数</h4><p><a href="https://leetcode.cn/problems/max-points-on-a-line/description/?envType=study-plan-v2&envId=top-interview-150">149. 直线上最多的点数 - 力扣（LeetCode）</a></p><p>枚举直线+哈希表：外层循环遍历每一个点，求出跟该点在同一条直线上的点的最大值，然后再得到所有点中的最大值。题目中用字符串保存斜率，求出x坐标差和y坐标差后，求出他们的最大公约数，分别除去再存储，可以有效的维护相同斜率的哈希表，也可以很好地使x坐标差为0的情况方便存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            map&lt;string, <span class="hljs-type">int</span>&gt; map;  <span class="hljs-comment">//每次循环都要重新构造哈希表</span><br>            <span class="hljs-type">int</span> maxv = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> x1 = points[i][<span class="hljs-number">0</span>], y1 = points[i][<span class="hljs-number">1</span>], x2 = points[j][<span class="hljs-number">0</span>], y2 = points[j][<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> a = x1 - x2, b = y1 - y2;<br>                <span class="hljs-type">int</span> k = <span class="hljs-built_in">gcd</span>(a, b);<br>                string key = <span class="hljs-built_in">to_string</span>(a / k) + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-built_in">to_string</span>(b / k);<br>                map[key]++;<br>                maxv = <span class="hljs-built_in">max</span>(maxv, map[key]);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, maxv + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<span class="hljs-comment">// 求最大公约数的代码</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>求最小公倍数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-comment">// 先求最大公约数</span><br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">gcd</span>(a, b);<br>    <span class="hljs-comment">// 利用最大公约数求最小公倍数</span><br>    <span class="hljs-keyword">return</span> (a * b) / num;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）零钱兑换（一维动规）"><a href="#（2）零钱兑换（一维动规）" class="headerlink" title="（2）零钱兑换（一维动规）"></a>（2）零钱兑换（一维动规）</h4><p><a href="https://leetcode.cn/problems/coin-change/?envType=study-plan-v2&envId=top-interview-150">322. 零钱兑换 - 力扣（LeetCode）</a></p><p>很好的题目，使我小脑萎缩。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>   <span class="hljs-type">int</span> MAX=amount+<span class="hljs-number">1</span>;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>,MAX)</span></span>;  <span class="hljs-comment">//若最后dp(amount)为max证明凑不到</span><br>   dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=amount;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-type">int</span>)coins.<span class="hljs-built_in">size</span>();++j)<br>         <span class="hljs-keyword">if</span>(coins[j]&lt;=i)<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-coins[j]]+<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> dp[amount]==MAX?<span class="hljs-number">-1</span>:dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++二叉树详解（概念+例题）</title>
    <link href="/2024/05/20/c++%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%A6%82%E5%BF%B5+%E4%BE%8B%E9%A2%98%EF%BC%89/"/>
    <url>/2024/05/20/c++%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%A6%82%E5%BF%B5+%E4%BE%8B%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>二叉树的学习记录</p><span id="more"></span><h3 id="一、二叉树相关概念"><a href="#一、二叉树相关概念" class="headerlink" title="一、二叉树相关概念"></a>一、二叉树相关概念</h3><h4 id="（1）二叉树的结构（照搬力扣网站）"><a href="#（1）二叉树的结构（照搬力扣网站）" class="headerlink" title="（1）二叉树的结构（照搬力扣网站）"></a>（1）二叉树的结构（照搬力扣网站）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br><span class="hljs-type">int</span> val;<br>TreeNode *left;<br>TreeNode *right;<br><span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>满二叉树&#x2F;完全二叉树（只有最后一层缺失，且只有右边缺失）</p><h4 id="（2）二叉搜索树"><a href="#（2）二叉搜索树" class="headerlink" title="（2）二叉搜索树"></a>（2）二叉搜索树</h4><h4 id="1、简单介绍"><a href="#1、简单介绍" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h4><p>一个节点左子树上的所有节点的值全部小于该节点，右子树上所有结点的值全部大于该节点。</p><p>作用：树如其名，二叉搜索树在搜索某个节点的值时速度更快。</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240522195705342.png" alt="image-20240522195705342" style="zoom: 67%;" /><p>如图，若想要找节点6，从根节点开始，小于根节点，找左子树；大于节点3，找右子树；等于节点6，找到节点。</p><p>除此之外，我们会发现这棵二叉搜索树的中序遍历：1.3.4.6.7.8.10.13.14</p><h4 id="2、二叉搜索树的搭建"><a href="#2、二叉搜索树的搭建" class="headerlink" title="2、二叉搜索树的搭建"></a>2、二叉搜索树的搭建</h4><p>(1)笨蛋版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>   TreeNode* temp=root;<br>   TreeNode* prev=<span class="hljs-literal">nullptr</span>;<br>   <span class="hljs-keyword">while</span>(temp)&#123;<br>      prev=temp;<br>      <span class="hljs-keyword">if</span>(k&lt;temp-&gt;val)<br>         temp=temp-&gt;next;<br>      <span class="hljs-keyword">else</span><br>         temp=temp-&gt;right;<br>   &#125;<br>   <span class="hljs-keyword">if</span>(k&lt;prev-&gt;val)&#123;<br>      TreeNode* curr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(k);<br>      prev-&gt;left=curr;<br>      curr-&gt;left=curr-&gt;right=<span class="hljs-literal">nullptr</span>;<br>   &#125;<br>   <span class="hljs-keyword">if</span>(k&gt;prev-&gt;val)&#123;<br>      TreeNode* curr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(k);<br>      prev-&gt;right=curr;<br>      curr-&gt;left=curr-&gt;right=<span class="hljs-literal">nullptr</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）调用自身搭建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">add</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(root=<span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num);<br>   <span class="hljs-keyword">if</span>(root-&gt;val&gt;num)<br>      root-&gt;left=<span class="hljs-built_in">add</span>(root-&gt;left,num);<br>   <span class="hljs-keyword">else</span><br>      root-&gt;right=<span class="hljs-built_in">add</span>(root-&gt;right,num);<br>   <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、二叉搜索树的例题"><a href="#3、二叉搜索树的例题" class="headerlink" title="3、二叉搜索树的例题"></a>3、二叉搜索树的例题</h4><h5 id="1-由二叉搜索树的中序遍历搭建二叉搜索树（傻眼）"><a href="#1-由二叉搜索树的中序遍历搭建二叉搜索树（傻眼）" class="headerlink" title="1&gt;由二叉搜索树的中序遍历搭建二叉搜索树（傻眼）"></a>1&gt;由二叉搜索树的中序遍历搭建二叉搜索树（傻眼）</h5><p>方法一：总是选取中序遍历中间位置左边的数字作为根节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function">TreeNode* <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span>(left&gt;right)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>   <span class="hljs-type">int</span> mid=(right+left)/<span class="hljs-number">2</span>;<br>   TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num[mid]);<br>   root-&gt;left=<span class="hljs-built_in">helper</span>(nums,left,mid<span class="hljs-number">-1</span>);<br>   root-&gt;right=<span class="hljs-built_in">helper</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>   <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：总是选取中序遍历中间位置左边的数字作为根节点（只需mid加一）</p><h5 id="2-找到二叉搜索树中第k大的节点值（k-cnt）"><a href="#2-找到二叉搜索树中第k大的节点值（k-cnt）" class="headerlink" title="2&gt;找到二叉搜索树中第k大的节点值（k&#x3D;cnt）"></a>2&gt;找到二叉搜索树中第k大的节点值（k&#x3D;cnt）</h5><p>方法一：（自写）（占用额外空间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myinorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">myinorder</span>(root-&gt;right,nums);<br>    nums.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">myinorder</span>(root-&gt;left,nums);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> cnt)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-built_in">myinorder</span>(root,nums);<br>    <span class="hljs-keyword">return</span> nums[cnt<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：优化（空间复杂度O(1)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> k;<span class="hljs-type">int</span> res;   <span class="hljs-comment">//必须是全局变量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myinorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">myinorder</span>(root-&gt;right);<br>    k--;<br>    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//迭代到倒数第k节点，是第k大的节点</span><br>       res=root-&gt;val;<br>       <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">myinorder</span>(root-&gt;left);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> cnt)</span> </span>&#123;<br>    k=cnt;<br>    <span class="hljs-built_in">myinorder</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-前序遍历构造二叉搜索树"><a href="#3-前序遍历构造二叉搜索树" class="headerlink" title="3&gt;前序遍历构造二叉搜索树"></a>3&gt;前序遍历构造二叉搜索树</h5><p>方法一：通过构建二叉搜索树的函数来构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">bstFromPreorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder)</span> </span>&#123;<br>   TreeNode* root =<span class="hljs-built_in">add</span>(<span class="hljs-literal">nullptr</span>, preorder[<span class="hljs-number">0</span>]);<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.<span class="hljs-built_in">size</span>(); i++) &#123;<br>       root=<span class="hljs-built_in">add</span>(root, preorder[i]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：已知二叉搜索树的中序遍历是有序的，因此我们现在知道了二叉树的前序和中序遍历（中序遍历可由前序遍历排序得出），就可以搭建了。（见下面第八道例题）</p><p>方法三：递归（分析前序遍历的特点：我们会发现，由根节点开始，第一个大于根节点的节点及其后均为右子树，中间的是左子树，依此类推）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">bstFromPreorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">mybst</span>(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-function">TreeNode* <span class="hljs-title">mybst</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(left&gt;right)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>   <span class="hljs-type">int</span> root=preorder[left];<br>   <span class="hljs-type">int</span> mid=left;<br>   <span class="hljs-keyword">for</span>(;mid&lt;=right+<span class="hljs-number">1</span>;mid++)<br>      <span class="hljs-keyword">if</span>(preorder[mid]&gt;root)<br>         <span class="hljs-keyword">break</span>;<br>   TreeNode* node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root);<br>   node-&gt;left=<span class="hljs-built_in">mybst</span>(preorder,left+<span class="hljs-number">1</span>,mid<span class="hljs-number">-1</span>);<br>   node-&gt;right=<span class="hljs-built_in">mybst</span>(preorder,mid,right);<br>   <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-二叉搜索树的最近公共祖先"><a href="#4-二叉搜索树的最近公共祖先" class="headerlink" title="4&gt;二叉搜索树的最近公共祖先"></a>4&gt;二叉搜索树的最近公共祖先</h5><p>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。（一个节点也可以是自己的祖先；最近：深度之差最小）</p><p>方法：递归（思路：找到分叉点。也就是两个节点都大于或者小于某个节点时，这个节点一定不是他们的最近公共祖先）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123; <span class="hljs-keyword">if</span>(p-&gt;val&lt;root-&gt;val&amp;&amp;q-&gt;val&lt;root-&gt;val)<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>   <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>   <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）二叉树的层次遍历（自顶向下）"><a href="#（3）二叉树的层次遍历（自顶向下）" class="headerlink" title="（3）二叉树的层次遍历（自顶向下）"></a>（3）二叉树的层次遍历（自顶向下）</h4><p>力扣题目链接：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><p>题目描述：给你二叉树的根节点 <code>root</code> ，返回其节点值的层序遍历。</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240520152406792.png" alt="image-20240520152406792" style="zoom:50%;" /><p>输入：root &#x3D; [ 3 , 9 , 20 , null , null , 15 , 7 ]<br>        输出：[ [3] , [ 9 , 20 ] , [ 15 , 7 ] ]</p><p><strong>广度优先搜索法：</strong></p><p>（一直以为广度优先搜索都是固定的那种函数模板，函数体里总会调用自身函数，现在看来不是这样。）</p><p>（广度：一层一层全部搜索完再去下一层；深度：走到底再返回）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector &lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ret;  <span class="hljs-comment">//存储返回值</span><br>   <span class="hljs-keyword">if</span>(!root)<br>      <span class="hljs-keyword">return</span> ret;    <span class="hljs-comment">//空树，返回空向量</span><br>   queue &lt;TreeNode*&gt; q;   <span class="hljs-comment">//存储每一层的节点</span><br>   q.<span class="hljs-built_in">push</span>(root);    <span class="hljs-comment">//先压入第一层（根节点）</span><br>   <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;   <span class="hljs-comment">//第一层循环：表示各层的存储过程</span><br>      <span class="hljs-type">int</span> curl=q.<span class="hljs-built_in">size</span>();<br>      ret.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());   <span class="hljs-comment">//每一层都要先添加一个空的向量，来存储这一层的节点值</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=curl;++i)&#123;   <span class="hljs-comment">//第二层循环：某一层的更新以及存储过程</span><br>         <span class="hljs-keyword">auto</span> node=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>         ret.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(node-&gt;val);  <span class="hljs-comment">//向最后一个向量后添加节点值</span><br>         <span class="hljs-keyword">if</span>(node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);  <span class="hljs-comment">//在队列内存储下层的节点值</span><br>         <span class="hljs-keyword">if</span>(node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路亦可改为每次循环新创建一个向量，然后压入每层节点值，最后再把这个向量压入二级向量中。</p><p><em><strong>二级向量数组</strong></em>：内层是向量，向量大小不固定；外层是存储这些向量的向量。</p><p><em><strong>emplace_push</strong></em>:据说速度要大于push_back。</p><h3 id="二、力扣刷题记录"><a href="#二、力扣刷题记录" class="headerlink" title="二、力扣刷题记录"></a>二、力扣刷题记录</h3><h4 id="（1）装饰树"><a href="#（1）装饰树" class="headerlink" title="（1）装饰树"></a>（1）装饰树</h4><p>装饰过程：在每个父节点与其子节点之间都插入一个值为-1的节点。返回完成装饰后树的根节点。<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240520171910175.png" alt="image-20240520171910175" style="zoom:67%;" /></p><p><strong>递归法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">expandBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">nullptr</span>)&#123;<br>      <span class="hljs-built_in">expandBinaryTree</span>(root-&gt;left);<br>      <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)&#123;<br>         TreeNode* T=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);<br>         T-&gt;left=root-&gt;left;<br>         root-&gt;left=T;<br>      &#125;<br>      <span class="hljs-built_in">expandBinaryTree</span>(root-&gt;right);<br>      <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>         TreeNode* T=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);<br>         T-&gt;right=root-&gt;right;<br>         root-&gt;right=T;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）求二叉树的最小深度"><a href="#（2）求二叉树的最小深度" class="headerlink" title="（2）求二叉树的最小深度"></a>（2）求二叉树的最小深度</h4><p>力扣题目链接：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>   <span class="hljs-comment">//只有左节点或右节点只能返回此节点的最小深度了（非叶子节点）</span><br>   <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">minDepth</span>(root-&gt;right)+<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">minDepth</span>(root-&gt;left) + <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">minDepth</span>(root-&gt;left), <span class="hljs-built_in">minDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>   <span class="hljs-comment">//叶子节点来选择最小深度</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）N叉树的前序遍历"><a href="#（3）N叉树的前序遍历" class="headerlink" title="（3）N叉树的前序遍历"></a>（3）N叉树的前序遍历</h4><p>力扣题目链接：<a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/">589. N 叉树的前序遍历 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> val;<br>vector&lt;Node*&gt; children;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>      vector&lt;<span class="hljs-type">int</span>&gt; res;<br>      <span class="hljs-built_in">helper</span>(root,res);<br>      <span class="hljs-keyword">return</span> res;<br>   &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-type">const</span> Node* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp; res)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>         <span class="hljs-keyword">return</span>;<br>      res.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; ch:root-&gt;children)<br>         <span class="hljs-built_in">helper</span>(ch,res);  <span class="hljs-comment">//对每个子节点都进行前序遍历</span><br>   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（4）克隆二叉树（递归）（无连接）"><a href="#（4）克隆二叉树（递归）（无连接）" class="headerlink" title="（4）克隆二叉树（递归）（无连接）"></a>（4）克隆二叉树（递归）（无连接）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">cloneTree</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(root==null)<br>      <span class="hljs-keyword">return</span> null;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode&#123;root.val,<span class="hljs-built_in">cloneTree</span>(root.left),<span class="hljs-built_in">cloneTree</span>(root.right)&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）翻转二叉树-递归"><a href="#（5）翻转二叉树-递归" class="headerlink" title="（5）翻转二叉树(递归)"></a>（5）翻转二叉树(递归)</h4><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(root==null)<br>      <span class="hljs-keyword">return</span> null;<br>   TreeNode* left=<span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>   TreeNode* right=<span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>   root-&gt;left=right;<br>   root-&gt;right=left;<br>   <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（6）相同的树-终于自己写会的递归，只是有细节不到位"><a href="#（6）相同的树-终于自己写会的递归，只是有细节不到位" class="headerlink" title="（6）相同的树(终于自己写会的递归，只是有细节不到位)"></a>（6）相同的树(终于自己写会的递归，只是有细节不到位)</h4><p><a href="https://leetcode.cn/problems/same-tree/description/">100. 相同的树 - 力扣（LeetCode）</a></p><p>错误版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(p-&gt;val!=q-&gt;val)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">if</span>(p==q==null)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(p-&gt;left,q-&gt;left)+<span class="hljs-built_in">isSameTree</span>(p-&gt;right,q-&gt;right)==<span class="hljs-number">2</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>&amp;&amp;q==<span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>||q==<span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//这个情况不要漏掉了</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(p-&gt;val!=q-&gt;val)   <span class="hljs-comment">//一定要先判断是不是空再取节点值！！！！！！！</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(p-&gt;left,q-&gt;left)&amp;&amp;<span class="hljs-built_in">isSameTree</span>(p-&gt;right,q-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（7）对称二叉树"><a href="#（7）对称二叉树" class="headerlink" title="（7）对称二叉树"></a>（7）对称二叉树</h4><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（LeetCode）</a></p><p>方法一：根据前几道题解来判断（反转后如果和原树相同说明是对称的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>TreeNode root1=<span class="hljs-built_in">invertTree</span>(root);<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(root1,root);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：递归（和判断是否是相同树很像）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">issame</span>(root,root);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">issame</span><span class="hljs-params">(TreeNode* l,TreeNode* r)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(l==<span class="hljs-literal">nullptr</span>&amp;&amp;r==<span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">if</span>(l==<span class="hljs-literal">nullptr</span>||r==<span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">return</span> l-&gt;val==r-&gt;val&amp;&amp;<span class="hljs-built_in">issame</span>(l-&gt;left,r-&gt;right)&amp;&amp;<span class="hljs-built_in">issame</span>(l-&gt;right,r-&gt;left);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（8）由遍历构造二叉树"><a href="#（8）由遍历构造二叉树" class="headerlink" title="（8）由遍历构造二叉树"></a>（8）由遍历构造二叉树</h4><h5 id="1-由前序遍历和中序遍历构造二叉树"><a href="#1-由前序遍历和中序遍历构造二叉树" class="headerlink" title="1&gt;由前序遍历和中序遍历构造二叉树"></a>1&gt;由前序遍历和中序遍历构造二叉树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">empty</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>   TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[<span class="hljs-number">0</span>]);<br>   <span class="hljs-comment">//pre.erase(pre.begin());</span><br>   <span class="hljs-type">int</span> size=<span class="hljs-built_in">find</span>(in.<span class="hljs-built_in">begin</span>(),in.<span class="hljs-built_in">end</span>(),pre[<span class="hljs-number">0</span>]);<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prel</span><span class="hljs-params">(pre.begin()+<span class="hljs-number">1</span>,pre.begin()+size+<span class="hljs-number">1</span>)</span></span>;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prer</span><span class="hljs-params">(pre.begin()+size+<span class="hljs-number">1</span>,pre.end())</span></span>;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inl</span><span class="hljs-params">(in.begin(),in.begin()+size)</span></span>;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inr</span><span class="hljs-params">(in.begin()+size+<span class="hljs-number">1</span>,in.end())</span></span>;<br>   root-&gt;left=<span class="hljs-built_in">mybuildTree</span>(prel,inl);<br>   root-&gt;right=<span class="hljs-built_in">mybuildTree</span>(prer,inr);<br>   <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++链表详解（概念+例题）</title>
    <link href="/2024/05/14/c++%E9%93%BE%E8%A1%A8%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%A6%82%E5%BF%B5+%E4%BE%8B%E9%A2%98%EF%BC%89/"/>
    <url>/2024/05/14/c++%E9%93%BE%E8%A1%A8%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%A6%82%E5%BF%B5+%E4%BE%8B%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>学不懂链表，写个博客浅浅记录一下链表的学习叭。</p><span id="more"></span><h3 id="一、数组与链表的区别"><a href="#一、数组与链表的区别" class="headerlink" title="一、数组与链表的区别"></a>一、数组与链表的区别</h3><p>面试中除了会问到栈和队列的区别，还可能会询问数组（顺序表）与链表的区别。我们也可以先从熟悉的数据结构：数组，通过分析它和链表的区别来体会链表的特征。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240517152625892.png" alt="image-20240517152625892"></p><h3 id="二、单链表的介绍"><a href="#二、单链表的介绍" class="headerlink" title="二、单链表的介绍"></a>二、单链表的介绍</h3><h4 id="1、单链表的结构"><a href="#1、单链表的结构" class="headerlink" title="1、单链表的结构"></a>1、单链表的结构</h4><h4 id="（1）图示"><a href="#（1）图示" class="headerlink" title="（1）图示"></a>（1）图示</h4><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240523151418436.png" alt="image-20240523151418436" style="zoom: 33%;" /><h4 id="（2）代码"><a href="#（2）代码" class="headerlink" title="（2）代码"></a>（2）代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Listnode</span><br>&#123;<br>    <span class="hljs-type">int</span> data;<br>    Listnode* next;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2、头插"><a href="#2、头插" class="headerlink" title="2、头插"></a>2、头插</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listcreatf</span><span class="hljs-params">(Listnode** head,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    Listnode* newnode=<span class="hljs-keyword">new</span> Listnode &#123;x,<span class="hljs-literal">NULL</span>&#125;;<br>    newnode-&gt;next=*head;  <span class="hljs-comment">//新指针指向原来的头指针</span><br>    *head=newnode;  <span class="hljs-comment">//新指针成为头指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>函数的第一个参数类型应该为<strong>二级指针</strong>，因为涉及到改变&#x2F;初始化头节点，这个操作需要为一级指针的值赋值。</p><h4 id="3、单链表的创建（尾插）"><a href="#3、单链表的创建（尾插）" class="headerlink" title="3、单链表的创建（尾插）"></a>3、单链表的创建（尾插）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listcreatb</span><span class="hljs-params">(Listnode** head,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//用new来创建一个新指针，值为x，指向为空   </span><br>    Listnode* newnode=<span class="hljs-keyword">new</span> Listnode &#123;x,<span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-keyword">if</span>(*head==<span class="hljs-literal">NULL</span>)&#123;  <span class="hljs-comment">//如果是空链表，将newnode作为头节点</span><br>        *head=newnode;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        Listnode* tail=*head;  <span class="hljs-comment">//每次插入新的节点都需要从头遍历</span><br>        <span class="hljs-keyword">while</span>(tail-&gt;next!=<span class="hljs-literal">NULL</span>)  <span class="hljs-comment">//目的是找到尾节点（它的指向为空）</span><br>            tail=tail-&gt;next;<br>        tail-&gt;next=newnode;  <span class="hljs-comment">//将新节点连接在尾节点后面，作为新的尾节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、链表的释放"><a href="#4、链表的释放" class="headerlink" title="4、链表的释放"></a>4、链表的释放</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listfree</span><span class="hljs-params">(Listnode** head)</span></span><br><span class="hljs-function"></span>&#123;<br>Listnode* cur;  <span class="hljs-comment">//新建一个节点</span><br>    <span class="hljs-keyword">while</span>(*head)&#123;<br>        cur=*head;  <span class="hljs-comment">//cur指向当前的头节点</span><br>        *head=cur-&gt;next;  <span class="hljs-comment">//下一位节点成为头节点</span><br>        <span class="hljs-built_in">delete</span>(cur);   <span class="hljs-comment">//删除头节点</span><br>        cur=<span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">//必须置空，否则会成为野指针</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、链表的打印"><a href="#5、链表的打印" class="headerlink" title="5、链表的打印"></a>5、链表的打印</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listprint</span><span class="hljs-params">(Listnode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>   listnode* cur=head;  <span class="hljs-comment">//cur节点指向头节点</span><br>   <span class="hljs-keyword">while</span>(cur)&#123;<br>      cout&lt;&lt;cur-&gt;data&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;  <span class="hljs-comment">//依次打印</span><br>      cur=cur-&gt;next;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、删除链表中的节点"><a href="#6、删除链表中的节点" class="headerlink" title="6、删除链表中的节点"></a>6、删除链表中的节点</h4><h4 id="（1）删除头节点"><a href="#（1）删除头节点" class="headerlink" title="（1）删除头节点"></a>（1）删除头节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listdeletef</span><span class="hljs-params">(Listnode** head)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(*head==<span class="hljs-literal">NULL</span>)<br>      <span class="hljs-keyword">return</span>;<br>   <span class="hljs-keyword">else</span>&#123;<br>      Listnode* newnode=(*head)-&gt;next;<br>      <span class="hljs-built_in">delete</span>(*head);<br>      *head=newnode;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）删除尾节点"><a href="#（2）删除尾节点" class="headerlink" title="（2）删除尾节点"></a>（2）删除尾节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listdeleteb</span><span class="hljs-params">(Listnode** head)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(*head==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">//空链表</span><br>      <span class="hljs-keyword">return</span>;<br>   <span class="hljs-keyword">if</span>((*head)-&gt;next==<span class="hljs-literal">NULL</span>)&#123;  <span class="hljs-comment">//只有一个节点</span><br>      <span class="hljs-built_in">delete</span>(*head);<br>      *head=<span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//需要置空</span><br>   &#125;<br>   <span class="hljs-keyword">else</span>&#123;<br>      Listnode* cur=*head;  <br>      Listnode* tmp=<span class="hljs-literal">NULL</span>;  <br>      <span class="hljs-keyword">while</span>(cur-&gt;next)&#123;<br>         tmp=cur;<br>         cur=cur-&gt;next;  <span class="hljs-comment">//找到尾节点</span><br>      &#125;<br>      <span class="hljs-built_in">delete</span>(cur);<br>      cur=<span class="hljs-literal">NULL</span>;<br>      tmp-&gt;next=<span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//tmp成为尾节点</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）删除等于给定值的所有节点"><a href="#（3）删除等于给定值的所有节点" class="headerlink" title="（3）删除等于给定值的所有节点"></a>（3）删除等于给定值的所有节点</h4><p>注意这个函数里会返回头节点因为函数参数只需要是一级指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Listnode* <span class="hljs-title">Listdelete</span><span class="hljs-params">(Listdode* head,<span class="hljs-type">int</span> x)</span>  </span><br><span class="hljs-function"></span>&#123;<br>   Listnode* tmp=<span class="hljs-literal">NULL</span>;Listnode* cur=head;<br>   <span class="hljs-keyword">while</span>(cur)&#123;<br>      <span class="hljs-keyword">if</span>(cur-&gt;data==x)&#123;<br>         <span class="hljs-keyword">if</span>(cur==head)&#123;   <span class="hljs-comment">//如果头节点就是要删除的节点</span><br>            head=cur-&gt;next;<br>            <span class="hljs-built_in">delete</span>(cur);<br>            cur=head;<br>         &#125;<br>         <span class="hljs-keyword">else</span>&#123;<br>            tmp-&gt;next=cur-&gt;next;<br>            <span class="hljs-built_in">delete</span>(cur);<br>            cur=tmp-&gt;next;<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span>&#123;<br>         tmp=cur;<br>         cur=cur-&gt;next;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）删除指定位置的节点"><a href="#（4）删除指定位置的节点" class="headerlink" title="（4）删除指定位置的节点"></a>（4）删除指定位置的节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">Listdeletepos</span><span class="hljs-params">(Listnode** head,Listnode* pos)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(*head==pos)&#123;<br>      *head=pos-&gt;next;<br>      <span class="hljs-built_in">delete</span>(pos);<br>      pos=<span class="hljs-literal">nullptr</span>;<br>   &#125;<br>   <span class="hljs-keyword">else</span>&#123;<br>      Listnode* cur=*head;<br>      <span class="hljs-keyword">while</span>(cur-&gt;next!=pos)&#123;<br>         cur=cur-&gt;next;<br>      &#125;<br>      cur-&gt;next=pos-&gt;next;<br>      <span class="hljs-built_in">delete</span>(pos);<br>      pos=<span class="hljs-literal">nullptr</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-链表元素的查找"><a href="#7-链表元素的查找" class="headerlink" title="7.链表元素的查找"></a>7.链表元素的查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Listnode* <span class="hljs-title">Listfind</span><span class="hljs-params">(Listnode* head,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>Listnode* cur=head;<br>   <span class="hljs-keyword">while</span>(cur)&#123;<br>      <span class="hljs-keyword">if</span>(cur-&gt;data==x)<br>         <span class="hljs-keyword">return</span> cur;<br>      <span class="hljs-keyword">else</span><br>         cur=cur-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-在指定位置后插入节点"><a href="#8-在指定位置后插入节点" class="headerlink" title="8.在指定位置后插入节点"></a>8.在指定位置后插入节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listinsertb</span><span class="hljs-params">(Listnode* pos,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>   Listnode* newnode=<span class="hljs-keyword">new</span> Listnode &#123;x,<span class="hljs-literal">NULL</span>&#125;;<br>   newnode-&gt;next=pos-&gt;next;<br>   pos-&gt;next=newnode;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、单链表的应用-例题"><a href="#三、单链表的应用-例题" class="headerlink" title="三、单链表的应用&amp;例题"></a>三、单链表的应用&amp;例题</h3><h4 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1.链表反转"></a>1.链表反转</h4><p>力扣题目连接：<a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></p><img src="C:/Users/姚姚/AppData/Roaming/Typora/typora-user-images/image-20240518103637208.png" alt="image-20240518103637208" style="zoom: 67%;" /><p><strong>方法一：迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>         ListNode* prev=<span class="hljs-literal">nullptr</span>;<br>         ListNode* curr=head;<br>         <span class="hljs-keyword">while</span>(curr)&#123;<br>            ListNode* next=curr-&gt;next;<br>            curr-&gt;next=prev;<br>            pre=curr;<br>            curr=next;<br>         &#125;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**-&gt;**图解分析：</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240523151338924.png" alt="image-20240523151338924" style="zoom: 33%;" /><p><strong>方法二：递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>         <span class="hljs-keyword">if</span>(!head||!head-&gt;next)<br>            <span class="hljs-keyword">return</span> head;<br>         ListNode* newhead=<span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>         head-&gt;next-&gt;next=head;<br>         head-&gt;next=<span class="hljs-literal">nullptr</span>;<br>         <span class="hljs-keyword">return</span> newhead;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-找到链表的中间节点"><a href="#2-找到链表的中间节点" class="headerlink" title="2.找到链表的中间节点"></a>2.找到链表的中间节点</h4><p>力扣题目链接：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/description/">876. 链表的中间结点 - 力扣（LeetCode）</a></p><p>题目描述：给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p><p><strong>方法一：遍历法</strong></p><p>先遍历一遍找到一共有多少个节点，再遍历一遍找到中间节点。当链表长度较长的时候，这种方法较为浪费时间。下面的方法只需要遍历一次。</p><p><strong>方法二：快慢指针法：</strong></p><p>定义两个指针，慢指针依次只走一步，快指针一次走两步。当快指针走到终点时，慢指针就刚好走到了中间节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>ListNode* slow,ListNode* fast;<br>   slow=fast=head;<br>   <span class="hljs-keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;<br>      slow=slow-&gt;next;<br>      fast=fast-&gt;next-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-移除重复节点"><a href="#3-移除重复节点" class="headerlink" title="3.移除重复节点"></a>3.移除重复节点</h4><p>力扣题目链接：<a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/description/">面试题 02.01. 移除重复节点 - 力扣（LeetCode）</a></p><p>题目描述：编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><p><strong>哈希表法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">removeDuplicateNodes</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>   ListNode* pre=<span class="hljs-literal">NULL</span>,*cur=head;  <span class="hljs-comment">//前后指针</span><br>   unordered_set&lt;<span class="hljs-type">int</span>&gt; list;  <span class="hljs-comment">//初始化哈希表</span><br>   <span class="hljs-keyword">while</span>(cur)&#123;  <span class="hljs-comment">//当指针不为空</span><br>      <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">find</span>(cur&gt;val)==list.<span class="hljs-built_in">end</span>())&#123;  <span class="hljs-comment">//没有该元素</span><br>         list.<span class="hljs-built_in">insert</span>(cur-&gt;val);  <span class="hljs-comment">//插入</span><br>         pre=cur;<br>      &#125;     <br>      <span class="hljs-keyword">else</span><br>         pre-&gt;next=cur-&gt;next;  <span class="hljs-comment">//如果表中已经有该元素，删除该指针</span><br>      cur=cur-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">//若头指针就为空则直接返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-找到链表的倒数第k个指针"><a href="#4-找到链表的倒数第k个指针" class="headerlink" title="4.找到链表的倒数第k个指针"></a>4.找到链表的倒数第k个指针</h4><p>力扣题目链接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthToLast</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>ListNode* pre,*cur;<br>   pre=cur=head;<br>   <span class="hljs-keyword">while</span>(k--)<br>      pre=pre-&gt;next;<br>   <span class="hljs-keyword">while</span>(pre)&#123;<br>      pre=pre-&gt;next;<br>      cur=cur-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">return</span> cur.val;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-判断链表是否为回文链表"><a href="#5-判断链表是否为回文链表" class="headerlink" title="5.判断链表是否为回文链表"></a>5.判断链表是否为回文链表</h4><p>力扣题目链接：</p><p><strong>方法一：复制元素到数组中再进行判断</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; list;<br>   <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)&#123;<br>      list.<span class="hljs-built_in">emplace_back</span>(head-&gt;val);<br>      head=head-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=list.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&lt;j;i++,j--)&#123;<br>      <span class="hljs-keyword">if</span>(list[i]!=list[j])<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ListNode* frontPointer;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recursivelyCheck</span><span class="hljs-params">(ListNode* currentNode)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (currentNode != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            frontPointer = frontPointer-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        frontPointer = head;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursivelyCheck</span>(head);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="6-相交链表"><a href="#6-相交链表" class="headerlink" title="6.相交链表"></a>6.相交链表</h4><p>力扣题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p><p>题目描述：给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。</p><p><strong>双指针法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(headA==<span class="hljs-literal">nullptr</span>||headB==<span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-keyword">return</span> null;<br>   ListNode* n1=headA,*n2=headB;<br>   <span class="hljs-keyword">while</span>(n1!=n2)&#123;<br>      n1=n1==<span class="hljs-literal">nullptr</span>?headB:n1-&gt;next;<br>      n2=n2==<span class="hljs-literal">nullptr</span>?headA:n2-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">return</span> n1;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-环路检测"><a href="#7-环路检测" class="headerlink" title="7.环路检测"></a>7.环路检测</h4><p>力扣题目链接：<a href="https://leetcode.cn/problems/linked-list-cycle-lcci/description/">面试题 02.08. 环路检测 - 力扣（LeetCode）</a></p><p>题目描述：给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。若环不存在，请返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p><strong>哈希表法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>   unordered_set&lt;ListNode*&gt; list;<br>   <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)&#123;<br>      <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">count</span>(head))<br>         <span class="hljs-keyword">return</span> head;<br>      list.<span class="hljs-built_in">insert</span>(head);<br>      head=head-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">return</span> null;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络面经</title>
    <link href="/2024/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>三、网络的七层协议，TCP UDP的区别 ，mac地址，ip 端口 子网掩码分别是干什么用的</p><p><strong>https 攻击方式</strong></p><p>1、数据被监听2、数据被篡改</p><p><strong>进程间有哪些通信方式</strong></p><p>管道、共享内存、消息队列、信号</p><p><strong>https是怎么加密的</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240509223423753.png" alt="image-20240509223423753"></p><p>加密就是把明⽂(要传输的信息)进行⼀系列变换, ⽣成密文；解密就是把密⽂再进⾏⼀系列变换, 还原成明文。</p><p>对称加密（算法公开、计算量⼩、加密速度快、加密效率高）、非对称加密（算法强度复杂、运算速度很慢）、数据摘要</p><p><strong>cpu调度算法的评价指标?</strong></p><p>cpu利用率、系统吞吐量、周转时间、等待时间、响应时间</p><p><strong>为什么说tcp是可靠的?</strong></p><p>TCP保证可靠性一般有以下几种方法：</p><p>检验和：在数据传输过程中，把传输的数据当作一个16位整数。吧所有的数据加起来，最前面的进位补到最后一位，然后取反得到校验和。发送方和接收方验证校验和是否相同。不相同则数据传输有误，相同也可能有问题。<br>确认应答：ACK和序列号（一应一答）机制保证数据的完整性（三次握手于四次挥手过程中通过比对Seq和ACK来实现）<br>超时重传：发送数据包在一定的时间周期内没有收到相应的ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送（也就是发送数据后，长时间没收到回应，会把数据再发一次。）<br>连接管理：三次握手，四次挥手<br>最大消息长度：理想的情况下是该长度的数据刚好不被网络层分块。<br>拥塞控制：控制传输上流量（发送数据时开始是慢启动，先发送一点点数据去探测网络拥塞不拥塞，如果不拥塞了，则大量的发送数据。如果突然拥塞了，则又很慢的发送数据。这样是为了尽可能快的发送数据，避免网络拥塞造成一系列问题）<br>流量控制：TCP利用滑动窗口实现流量控制，流量控制是为了控制发送方的发送速率，保证接收方可以及时接收</p><p><strong>网络协议有哪些？</strong></p><p>1、HTTP（Hypertext Transfer Protocol）协议是一种用于传输超文本的协议，通常用于在Web浏览器和Web服务器之间传递数据。它基于请求-响应模型：客户端发送HTTP请求，服务器返回HTTP响应。通信使用明文进行，不具备加密性。lHTTP广泛应用于Web开发，用于获取网页、传输HTML、CSS、JavaScript等资源。它的无状态特性使其适用于快速、轻量级的数据传输。</p><p>HTTP协议的特点</p><p>支持服务器&#x2F;客户端模式</p><p>传输较快速，客户端向服务器发送请求，只需要传输请求方法和路径</p><p>灵活，HTTP允许传输任意类型的数据对象</p><p>无连接，每次连接只能处理一个请求，服务器处理完客户端请求，客户端收到响应后就断开连接</p><p>无状态，协议本身对事务处理没有记忆能力，如果后序连接需要之前发送的信息时就需要重传</p><p>(1)HTTP1.0和HTTP1.1的区别：</p><p>长连接：HTTP1.0只支持浏览器与服务器的短连接，即每次请求都要重新建立连接，服务器无法记录每个历史请求，HTTP1.1支持长连接即在一次连接下，浏览器可以向服务器发送多次请求</p><p>增加Host字段：HTTP1.0中认为每个服务器都绑定这唯一一个IP，所有发送的请求头URL中没有host信息，而HTTP1.1在请求和响应中都支持了host头域，且请求消息中如果没有Host头域会报告一个错误(400 Bad Request)</p><p>缓存：HTTP1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。</p><p>错误提示：HTTP1.0中定义了16个状态码，对错误或警告的提示不够具体。HTTP1.1引入了一个Warning头域，增加对错误或警告信息的描述，并且还新增了24个状态响应码，如409(Conflict)表示请求的资源与资源的当前状态发生冲突；410(Gone)表示服务器上的某个资源被永久性的删除</p><p>(2)HTTP1.X和HTTP2.0的区别</p><p>增加二进制格式解析：HTTP1.X解析基于文本，而文本格式本身就具有多样性，很多场景下不方便，而引入二进制后，只有0和1组合，使解析更加方便也增强了健壮性</p><p>多路复用：即每个request都是是用作连接共享机制的，每个request都对应一个id，使一个连接可以有多个请求，再根据id将request归属到不同的服务端请求里</p><p>header压缩：HTTP1.X中，每次传输都要写点header头，占用了大量数据，因此HTTP2.0在客户端和服务端各保存了一份header fields表，每次传输时只需传输header的更新信息，将header fields表更新即可实现header传输</p><p>2、SMTP（Simple Mail Transfer Protocol）是一种电子邮件传输协议，用于在邮件客户端和邮件服务器之间传递电子邮件。它定义了邮件的格式以及在不同设备之间的传递方式。</p><p>3、FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议。它支持用户通过用户名和密码进行身份验证，并提供文件上传和下载功能。</p><p>4、DNS（Domain Name System）是一种将域名映射到IP地址的分布式数据库系统。它允许用户使用易记的域名而不是复杂的IP地址访问互联网资源。</p><p><strong>避免缓存雪崩如何实现</strong></p><p>缓存雪崩是指在某个时间点，大量缓存同时失效，导致大量请求直接落到<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">数据库</a>上，造成数据库负载激增的现象。</p><p>1 合理设置缓存失效时间：<br>将缓存的失效时间分散开，避免同时失效。可以在原有的失效时间基础上，加上一个随机的时间偏移，或者使用带有范围的失效时间。</p><p>2 采用永不过期策略：<br>对于热点数据，可以考虑使用永不过期的策略，即在缓存中永远不主动删除，而在数据更新时手动刷新缓存。这样可以避免大量缓存同时失效的情况。</p><p>3 使用多级缓存：<br>引入多级缓存架构，例如本地缓存、分布式缓存（如Redis）、全局缓存（如CDN），这样即使一个级别的缓存失效，其他级别的缓存仍然可以提供服务，降低缓存雪崩的风险。</p><p>4 缓存预热：<br>在系统启动或低峰期，提前加载热门数据到缓存中，避免在高峰期大量请求涌入时触发缓存失效。</p><p>5 限流和熔断：<br>实施限流和熔断机制，控制并发访问的数量，防止瞬时请求过多导致缓存雪崩。</p><p>6 缓存穿透保护：<br>使用类似布隆过滤器算法，防止缓存穿透，即查询一个不存在的数据导致缓存和数据库都不命中。</p><p>7 灾备机制：<br>部署灾备机制，当主缓存出现问题时，可以切换到备用缓存，保障系统的可用性。</p><p>8 分批更新缓存：<br>当大量数据需要更新时，采用分批更新的方式，避免一次性大规模的缓存更新。</p><p><strong>protocol buffer</strong></p><p><strong>Speed协议</strong></p><p><strong>2.TCP和UDP区别</strong><br>① TCP协议是有连接的，即在传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束后还要结束连接。而UDP是无连接的。<br>②TCP协议保证数据按序发送以及到达，超时重传来保证可靠性，但是UDP不保证按序到达，不保证到达，只是努力交付，即使是按序发送的序列，也不保准按序送到。<br>③TCP协议所需的资源多，首部需要20个字节，UDP首部只需要8个字节<br>④TCP有流量控制和拥塞控制，UDP有没有网络堵塞不会影响发送端的发送速率。<br>⑤TCP是一对一连接，而UDP是一对一 一对多 多对多的通信<br>⑥TCP面向的是字节流的服务，UDP面向的是报文的服务。</p><p>4.<strong>进程和程序的区别</strong><br>①进程是程序的一次执行。<br>②进程是可以并行执行的计算<br>③进程是一个程序与其使用的数据在处理机上顺序执行时发生的活动。<br>④进程是系统进行资源分配和调度的一个独立单位<br>本质区别：<br>①程序是永存的，进程是暂时的<br>②进程有并发性，程序没有<br>③二者不是一一对应关系，一个程序可以对应多个进程，多个进程可执行同一个程序，一个进程可执行一个或者几个程序<br>④进程是竞争计算机资源的基本单位，但是程序不是。</p><h5 id="为啥不多进程而是多线程呢？"><a href="#为啥不多进程而是多线程呢？" class="headerlink" title="为啥不多进程而是多线程呢？"></a>为啥不多进程而是多线程呢？</h5><p>答：线程廉价且启动较快，对系统资源的冲击比较小，多进程不可预测且测试困难。</p><p>7.读写锁（这个不会，但好像也挺基础的）<br>读锁是共享的<br>　写锁是排他的<br>　<br>读-读能共存，<br>读-写不能共存，<br>写-写不能共存。</p><p>8.堆和栈<br>栈内存：存储局部变量，更新速度快，声明周期短<br>堆内存：存储数组和对象，凡是new建立的都是在堆中，堆中存放的是实体，实体用于封装数据，java垃圾回收（不定时）。</p><p>9.虚拟内存和实际内存（操作系统学的，有点久远）<br>当虚拟内存中的值真正需要用的时候，物理内存才会开辟一段地址来存储虚拟内存中的值<br>所以真正能使用的物理内存的大小则为：虚拟内存(pagefile.sys) + 物理内存</p><p>10.抢占式进程调度（这个也不会，菜哭了）<br>最常见的现象是你这个进程运行时间太长了，是时候切换到另一个进程了</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240509221747850.png" alt="image-20240509221747850"></p><h6 id="tcp和udp应用场景"><a href="#tcp和udp应用场景" class="headerlink" title="tcp和udp应用场景"></a>tcp和udp应用场景</h6><p>tcp：文件传输、接收邮件、远程登录<br>udp：在线视频、qq聊天、广播通信</p><p>对于3次握手：主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。<br>对于4次挥手：其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。</p><p>拥塞控制主要是四个算法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">慢启动<br>拥塞避免<br>拥塞发生<br>快速恢复<br></code></pre></td></tr></table></figure><p><strong>浏览器输入一个URL按下回车后，其流程是？</strong></p><p>分析：如果要连接到远程服务器，首先要知道服务器的IP地址和端口，然后发送请求到服务器，服务器再响应。因此寻址和如何建立连接是关键。</p><p>步骤：</p><p>（1）进行寻址：若浏览器缓存中存有URL的对应IP，则直接查询IP；否则访问DNS（Domain Name System）进行寻址（Domain Name Resolution）。</p><p>（2） DNS或者URL Cache返回网页服务器的IP地址。</p><p>（3）浏览器与网页服务器进行三次握手建立TCP连接。由于是网页浏览服务，故连接到服务器的80端口。</p><p>（4）浏览器与服务器建立HTTP会话（Session），接收来自服务器的HTTP数据。</p><p>（5）浏览器解析HTTP数据，在本地窗口内渲染并显示网页。</p><p>（6）当浏览器页面被关闭时，终止HTTP会话并关闭连接。</p><p><strong>多线程建立有哪几种方法</strong></p><p>继承thread、建立线程池、实现Runnable、实现Callable</p><p><strong>多线程并发的三大特性</strong></p><p>可见性、原子性（要么全部执行且不会被打乱要么全部不执行）、有序性</p><h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><p>浏览器多样化，需要考虑兼容性的问题，传统方式布局比较繁杂</p><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>移动端浏览器大部分内核为<a href="https://so.csdn.net/so/search?q=webkit&spm=1001.2101.3001.7020">webkit</a>，不需要考虑兼容性的问题，且移动端可以放心使用flex弹性布局</p><p>移动端技术解决方案</p><p>移动端浏览器<br>移动端浏览器基本以webkit内核为主,因此我们就考虑webkit兼容性问题<br>我们可以放心使用H5标签和css3样式<br>同时我们浏览器的私有前缀我们只需要考虑添加webkit即可</p><p>css初始化 normalize.css<br>移动端css初始化推荐使用normalize.css<br>好处<br>保护了有价值的默认值<br>修复了浏览器的bug<br>是模块化的<br>拥有详细的文档<br>网址 : <a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></p><p>css3 盒子模型 box-sizing<br>box-sizing:border-box<br>padding和border不会在撑大盒子了<br>默认值<br>box-sizing:content-box<br>padding和border和原来一样会在撑大盒子</p>]]></content>
    
    
    <categories>
      
      <category>八股面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp面经（杂乱版）</title>
    <link href="/2024/05/09/cpp%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/05/09/cpp%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>什么是虚函数？</strong><br>被 <a href="https://so.csdn.net/so/search?q=virtual&spm=1001.2101.3001.7020">virtual</a> 关键字修饰的成员函数称为虚函数。<br><a href="https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">虚函数</a>的作用是实现多态性，即通过基类访问派生类的函数。<br><strong>什么是纯虚函数？</strong><br>在虚函数后面添加 &#x3D;0 ，虚函数就成为<a href="https://so.csdn.net/so/search?q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">纯虚函数</a>，<br>在很多情况下，基类生成对象很不合理。为了解决这个问题，引入了纯虚函数的概念，将函数定义为纯虚函数，派生类中必须重写实现纯虚函数。对于实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。</p><h5 id="auto-ptr能作为vector的元素吗？为什么？"><a href="#auto-ptr能作为vector的元素吗？为什么？" class="headerlink" title="auto_ptr能作为vector的元素吗？为什么？"></a>auto_ptr能作为vector的元素吗？为什么？</h5><p>答：不可以。<br>当复制一个auto_ptr时，它所指向的对象的所有权被交到复制的auto_ptr上面，而它自身将被设置为null。复制一个auto_ptr意味着改变它的值。</p><p><strong>死锁的四个必要条件</strong></p><p>1、 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><p>2、不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p><p>3、 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><p>4、循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</p><pre><code class="hljs">预防：通过设置某些限制条件，以破坏产生死锁的条件，来防止发生死锁。避免：系统在分配资源时根据资源的使用情况提前作出预测，从而避免死锁的发生。检测：允许系统在运行的过程中产生死锁，但是，系统中有相应的管理模块可以及时检测出已经产生的死锁，并且精确地确定与死锁有关的进程和资源，然后采取适当措施，清除系统中已经产生的死锁。解除：与检测死锁相配套的一种措施，用于将进程从死锁状态下解脱出来。</code></pre><p><strong>进程调度</strong></p><p>在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程并发执行。</p><p>先来先服务（FCFS）调度算法、短作业优先（SJF）调度算法、优先级调度算法、高响应比优先调度算法</p><p><strong>进程与线程的区别</strong></p><p>本质区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</p><p>包含关系：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>资源开销：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</p><p>影响关系：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。</p><p><strong>一个基本的事实前提</strong>：<strong>一个CPU在一个瞬间只能处理一个任务</strong>。</p><p>并发（Concurrent）：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。<br>同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p>并行（Parallel）：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240509203458598.png" alt="image-20240509203458598"></p><p><strong>哈希冲突</strong></p><p>当两个不同的数经过哈希函数计算后得到了同一个结果，即他们会被映射到哈希表的同一个位置时，即称为发生了哈希冲突。简单来说就是哈希函数算出来的地址被别的元素占用了。</p><h6 id="开放定址法：我们在遇到哈希冲突时，去寻找一个新的空闲的哈希地址。（链地址法、公共溢出区法）"><a href="#开放定址法：我们在遇到哈希冲突时，去寻找一个新的空闲的哈希地址。（链地址法、公共溢出区法）" class="headerlink" title="开放定址法：我们在遇到哈希冲突时，去寻找一个新的空闲的哈希地址。（链地址法、公共溢出区法）"></a><strong>开放定址法：我们在遇到哈希冲突时，去寻找一个新的空闲的哈希地址。</strong>（链地址法、公共溢出区法）</h6><p>数据库索引<br><strong>堆栈的区别</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">一个由c/C++编译的程序占用的内存分为以下几个部分 <br>  <span class="hljs-number">1</span>、栈区（stack）―   由编译器自动分配释放。用来存储函数调用时的临时信息的结构，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。 <br>  <span class="hljs-number">2</span>、堆区（heap） ―   一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。<br>     注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 <br>  <span class="hljs-number">3</span>、全局区（静态区）（<span class="hljs-type">static</span>）―，全局变量和静态变量的存储是放在一块的，<br>     初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放 <br>  <span class="hljs-number">4</span>、文字常量区  ―常量字符串就是放在这里的。 程序结束后由系统释放 <br>  <span class="hljs-number">5</span>、程序代码区―存放函数体的二进制代码。<br></code></pre></td></tr></table></figure><p><strong>栈和队列的区别、数组和链表有什么区别</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240509163720074.png" alt="image-20240509163720074"></p><p>c语言中常用的数据结构<br><strong>两个堆怎么实现一个队列</strong><br>二叉树的前中后序遍历输出结果</p><ul><li><p>HashMap原理，为什么每次扩容都是2的倍数，为什么由头插改成了尾插，环化是怎么引起的</p></li><li><p>快排和堆排的原理</p><p>当面试官询问 C++ 相关的常见八股知识时，他们可能会深入以下几个方面：</p><ol><li><p><strong>C++ 的特性和优势</strong>：</p><ul><li>C++ 是一种通用编程语言，继承了 C 语言的功能并加入了面向对象编程的特性。</li><li>C++ 具有高效性、灵活性和可移植性等优势，可以直接操作硬件并实现高性能的应用程序。</li></ul></li><li><p><strong>类与对象</strong>：</p><ul><li>类是用户自定义的数据类型，用于描述具有相同属性和行为的对象的集合。</li><li>对象是类的一个实例，具有类定义的属性和行为。</li><li>构造函数用于初始化对象的状态，析构函数用于清理对象所占用的资源。</li></ul></li><li><p><strong>继承与多态</strong>：</p><ul><li>继承是面向对象编程中一种机制，允许一个类继承另一个类的属性和行为。</li><li>多态性允许不同对象对同一消息做出不同的响应，提高了代码的灵活性和可扩展性。</li><li>虚函数是在基类中声明的带有 virtual 关键字的函数，派生类可以重写这些函数以实现多态。</li></ul></li><li><p><strong>模板与泛型编程</strong>：</p><ul><li>模板是一种通用的代码结构，可以用于生成特定数据类型的函数或类。</li><li>模板的特化和偏特化允许针对特定类型提供定制的实现。</li><li>泛型编程是一种编程范式，旨在编写与特定数据类型无关的代码。</li></ul></li><li><p><strong>异常处理</strong>：</p><ul><li>异常是程序执行过程中发生的意外事件。</li><li>异常处理是一种机制，用于在程序中检测、报告和处理异常。</li><li>C++ 中的异常处理关键字包括 try、catch 和 throw。</li></ul></li><li><p><strong>内存管理</strong>：</p><ul><li>栈是一种自动分配和释放内存的数据结构，用于存储函数调用、局部变量等。</li><li>堆是一种动态分配和释放内存的数据结构，用于存储程序运行时动态创建的对象。</li></ul></li><li><p><strong>STL（标准模板库）</strong>：</p><ul><li>STL 提供了丰富的数据结构和算法，包括向量、链表、映射、集合等容器以及排序、搜索、迭代等算法。</li><li>迭代器是一种抽象的数据访问接口，用于遍历容器中的元素。</li></ul></li><li><p><strong>并发编程</strong>：</p><ul><li>C++11 引入了一套新的并发编程库，包括线程、原子操作、互斥量、条件变量等。</li><li>线程同步的机制包括互斥量、条件变量和原子操作，用于确保多个线程之间的数据一致性和同步执行。</li></ul></li></ol><p>以上是对常见 C++ 八股知识的详细解答，你可以根据自己的理解和经验进一步扩展和完善。</p></li><li><p><strong>重载重写隐藏</strong></p><p>一、重载</p><ul><li>相同的作用域内</li><li>参数列表不同（参数的类型，个数，顺序不同）</li><li>函数名字相同；函数返回类型相同</li></ul><p>二、重写</p><ul><li>不在同一个作用域（分别位于<a href="https://so.csdn.net/so/search?q=%E6%B4%BE%E7%94%9F%E7%B1%BB&spm=1001.2101.3001.7020">派生类</a>与基类） ；</li><li>基类函数必须有 <strong>virtual</strong> 关键字，不能有 static 。</li><li>函数名字相同；参数相同；返回值相同</li><li>函数体不同</li></ul><p>三、隐藏</p><p>​不在同一个作用域（分别位于派生类与基类） ；</p><p>​函数名字相同；</p><p>​参数、返回值、函数体都可以不同；</p></li><li><p><strong>什么函数可以&#x2F;不可以声明为虚函数</strong></p></li></ul><p>​<a href="https://so.csdn.net/so/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">析构函数</a> 普通的成员函数</p><p>​普通函数（非成员函数）、构造函数、内联函数、静态函数、友元函数。</p><ul><li><p><strong>vector和list的使用场景</strong></p><p>vector适用：对象数量变化少，简单对象，随机访问元素频繁<br>list适用：对象数量变化大，对象复杂，插入和删除频繁<br>最大的区别是,list是双向的，而vector是单向的。<br>因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：<br>1）、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector<br>2)、如果你需要大量的插入和删除，而不关心随即存取，则应使用list<br>3)、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p></li><li><p><strong>stack适配器的底层容器是什么，能不能用vector，为什么</strong></p></li></ul><p>1 stack 堆栈适配器 （ 可用的容器类型 vector deque list）默认是deque<br>2 queue 队列适配器 ( 可用的容器类型 deque list)默认的容器是deque<br>3 priority_queue 优先级队列 (可用的容器类型 deque vector)默认是vector|<br>                        底层容器必须支持随机访问迭代器，因此底层容器可以是deque，不能是list</p><ul><li><strong>什么情况下需要使用多继承</strong></li></ul><p>一个子类拥有很多父类 ,一般指一个类有2个以上父类。</p><ul><li>STL中的多继承</li><li><strong>虚继承原理</strong></li></ul><p>所谓虚继承（virtual）就是子类中只有一份间接父类的数据。该技术用于解决<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020">多继承</a>中的父类为非虚基类时出现的数据冗余问题，即菱形继承问题。</p><p>在上图中，父类数据并不存放在虚继承的子类中，那么子类怎么找到父类数据呢？</p><p>——在虚继承的类中，会定义一个<strong>虚基表指针vbptr</strong>，<strong>指向虚基表</strong>。(虚表在<strong>构造函数之前</strong>写入)</p><p>而虚<strong>基表中会存在偏移量，这个量就是表的地址到父类数据地址的距离</strong>。</p><p>我们可以通过调试，找到虚基表指针和虚基表：</p><ul><li><strong>右值引用和移动语义</strong></li></ul><p>可以被取地址的、有名字的都是左值，反之不能取地址的、没有名字的就是右值。</p><p>右值：<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F&spm=1001.2101.3001.7020">字面常量</a>，表达式，函数的非引用返回值，在表达式求值过程中临时创建的对象，这些使用过后就被销毁的资源</p><p>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。普通的函数和操作符也可以利用右值引用操作符实现转移语义。</p><ul><li><strong>C++内存管理方式</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240509170056071.png" alt="image-20240509170056071"></p><p>一、自动存储</p><p>在函数内部定义的常规变量使用自动存储空间，被称为<strong>自动变量</strong>（automatic variable），这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。<strong>自动变量通常存储在栈中</strong>。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放着些变量，着被称为<a href="https://so.csdn.net/so/search?q=%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA&spm=1001.2101.3001.7020">后进先出</a>（LIFO）。因此，在程序执行过程中，栈将不断地增大和缩小。</p><p>二、静态存储</p><p>静态存储是整个程序执行期间都存在的存储方式。使变量称为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static</p><p>三、动态存储<br>new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。new和delete让您能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的声明周期不完全受程序或函数的生命时间控制。与使用常规变量相比，使用new和delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，单new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。</p><p>四、线程存储</p><ul><li>shared ptr的具体实现（问的很细</li></ul><p><strong>栈、堆、内存泄漏</strong><br>如果使用new在自由存储空间（或堆）上创建变量后，没有调用delete。会发生什么？</p><p>即使包含指针的内存（由于作用域规则和对象生命周期的原因而）被释放，在自由存储空间上动态分配的变量或结构依然存在。</p><p>则将会无法访问自由存储空间的结构，因为指向这些内存的指针无效。</p><p>这将导致<strong>内存泄露</strong>，被泄漏的内存在程序的整个生命周期将不可使用，这些内存被分配，但无法被使用。</p><p><strong>引用和指针的区别</strong></p><p>\1. 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；</p><p>\2. 引用使用时无需解引用(*)，指针需要解引用；</p><p>\3. 引用只能在定义时被初始化一次，之后不可变；指针可变；</p><p>\4. 引用没有 const，指针有 const；</p><p>\5. 引用不能为空，指针可以为空；</p><p>\6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</p><p>\7. 指针和引用的自增(++)运算意义不一样；</p><p>\8. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</p><p>9.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</p><p><strong>tcp滑动窗口</strong></p><p>滑动窗口机制是TCP协议中实现流量控制和可靠传输的关键技术。它的主要工作原理如下：</p><ol><li>发送方维护一个发送窗口，这是一个连续的字节序列，表示发送方可以发送的字节数范围。发送窗口由两个参数定义：窗口的起始字节和窗口的大小。发送方将数据分成多个数据段，并按顺序发送到接收方。</li><li>接收方使用确认号来通知发送方已成功接收到的数据。确认号表示接收方期望接收的下一个字节的序列号。同时，接收方还会通告一个窗口大小，告诉发送方自己的接收缓冲区还能容纳多少字节的数据。</li><li>发送方根据接收方通告的窗口大小进行数据发送控制。如果接收方的窗口变大，发送方可以发送更多的数据；如果接收方的窗口变小，发送方需要适应减少的窗口大小。这样，发送方可以持续发送数据而不需要等待每个数据段的确认，从而提高了传输效率。</li></ol><p>滑动窗口机制在数据传输中起到了流量控制和可靠性传输的重要作用。通过动态调整窗口大小，接收方可以控制发送方的数据发送速率，避免网络拥塞和数据丢失。同时，滑动窗口机制还确保了数据的顺序传输和可靠接收，为TCP协议提供了可靠的传输服务。</p><p><strong>二分查找的时间复杂度、二分查找的具体操作</strong></p><p>O(logn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (L &lt; R)&#123;                      <span class="hljs-comment">//一直二分，直到区间[L,R]缩小到L=R</span><br>    <span class="hljs-type">int</span> mid = (L + R) / <span class="hljs-number">2</span>;          <span class="hljs-comment">//mid是L、R的中间值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))  R = mid;       <span class="hljs-comment">//答案在左半部分[L,mid]，更新R=mid</span><br>    <span class="hljs-keyword">else</span>             L = mid + <span class="hljs-number">1</span>;   <span class="hljs-comment">//答案在右半部分[mid+1, R]，更新L=mid+1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>11.n个数中找出最小的k个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span> || input.<span class="hljs-built_in">size</span>() &lt; k)<br>            <span class="hljs-keyword">return</span> ret;<br>        priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt; &gt; pq;(大根堆)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; input.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &lt; k)<br>                pq.<span class="hljs-built_in">push</span>(input[i]);<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(input[i] &lt; pq.<span class="hljs-built_in">top</span>())&#123;<br>                    pq.<span class="hljs-built_in">pop</span>();<br>                    pq.<span class="hljs-built_in">push</span>(input[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>            ret.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>());<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>priority_queue&lt;int,vector<int>,greater<int> &gt;q;  (小根堆)</p><p><strong>为什么父类的析构函数为什么不调用子类的虚函数</strong>（因为子类早就被析构了）<br>IO多路复用select&#x2F;poll&#x2F;epoll<br>什么情况下select比epoll好</p><p><strong>全局变量和static全局变量有啥不同</strong></p><p>1.两者<a href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>不同，全局变量的作用域是整个工程项目，静态全局变量作用域只在当前文件</p><p>2.全局变量在其他文件引用时，需使用<a href="https://so.csdn.net/so/search?q=extern&spm=1001.2101.3001.7020">extern</a>声明</p><p>3.全局变量和静态全局变量都存储在静态存储区</p><p>4.全局变量和静态全局变量都是定义在函数外或类外</p><p><strong>define和type define的不同</strong></p><p>1、作用域不同<br>#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。<br>typedef有自己的作用域，只能在作用域内使用。</p><p>2、对指针的操作不同<br>例如：</p><p>typedef    int*      INTp1 ;</p><p>#define    INTp2    int* ;<br>上面两种看似效果一样，实则不同！具体区别如下：<br>INTp1 a,b等同于int *a; int *b;表示定义了两个整型指针变量。<br>而INTp2 a,b等同于int *a, b; 表示定义了一个整型指针变量a和整型变量b。</p><p>3、 功能不同<br>#define 虽然只是简单的替换，但是也可为为类型取别名，还可以定义常量、变量和编译开关等；<br>typedef可用来定义类型的别名，这些类型不只包含内部类型（int，double，long long,char等），还包括自定义类型（如struct），可以起到使类型易于记忆的功能,增强程序的可读性。</p><p>4、原理不同<br>define不分配内存，给出的是⽴即数，有多少次使⽤就进⾏多少次替换。</p><p>typedef在静态存储区中分配空间，在程序运⾏过程中内存中只有⼀个拷贝。</p><p><strong>互斥锁</strong></p><p>互斥锁、自旋锁和读写锁用于解决多线程同步的问题</p><p>sizeof和strlen的区别</p><p>violate关键字</p><h5 id="14-set的使用场景，map使用场景"><a href="#14-set的使用场景，map使用场景" class="headerlink" title="14.set的使用场景，map使用场景"></a>14.set的使用场景，map使用场景</h5><p>set可以做到整数数组的去重，但是对象就不可以。<br>map中的集合，元素成对存在，每个元素由键和值两部分组成。</p><p><strong>问2：C和C++的区别？</strong></p><p>答：c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。</p><p>1.<br>   语言本身：</p><ol><li>C++是面向对象语言，C是面向过程语言。</li><li>结构：C以结构体struct为核心结构；C++以类class为核心结构。</li><li>多态：C可以以宏定义的方式“自定义”部分地支持多态；C++自身提供多态，并以模板templates支持编译期多态，以虚函数virtual function支持运行期多态。</li><li>头文件的调用：C++用&lt; &gt;代替” “代表系统头文件；且复用C的头文件时，去掉”.h”在开头加上”C”。</li><li>输入输出：鉴于C++中以对象作为核心，输入和输出都是在流对象上的操作。</li><li>封装：C中的封装由于struct的特性全部为公有封装，C++中的封装由于class的特性更加完善、安全。</li><li>常见风格：C中常用宏定义来进行文本替换，不具有类型安全性；C++中常建议采用常量定义，具有类型安全性。</li><li>效率：常见的说法是同等目的C通常比C++更富有效率(这其实有一定的误解，主要在于C++代码更难于优化且少有人使用编译期求值的特性)。</li><li>常用语言&#x2F;库特性：<ol><li>数组：C中采用内建数组，C++中建议采用vector。相比之下vector的大小可以动态增长，且使用一些技巧后增长并不低效，且成员函数丰富。</li><li>字符串 C中采用C风格的string(实则为字符串数组)，C++中建议采用string，对比与上一条类似。</li><li>内存分配：C中使用malloc与free，它们是是C标准库函数，C++中建议使用new&#x2F;delete代替前者，他们说是C++的运算符(这是笔试面试常考点)以C++中的new为例，new可分为operator new(new 操作)、new operator(new 操作符)和placement new(定位 new)。其中operator new执行和malloc相同的任务，即分配内存，但对构造函数一无所知；而 new operator则调用operator new，分配内存后再调用对象构造函数进行对象的构造。其中operator new是可以重载的。placement new，就是operator new的一个重载版本，允许你在一个已经分配好的内存中构造一个新的对象。</li><li>指针：C中通常使用的是原生指针(raw pointer)，由于常出现程序员在申请后忘记释放造成资源泄漏的问题，在C++98中加入了“第一代”基于引用计数的智能指针auto_ptr，由于初代的各种问题(主要是无法解决循环指针)，在03标准也就是TR1中引入了shared_ptr,weak_ptr和unique_ptr这三个功能各异的智能指针，并与11标准中正式确定，较好的解决了上述问题。</li></ol></li><li>仅有C++才有的常用特性：<ol><li>语言(范式)特性：<ol><li>面向对象编程：C++中以关键字class和多态特性支持的一种编程范式；</li><li>泛型编程：C++中以关键字template支持的一种编程范式；</li><li>模板元编程 ：C++中以模板特化和模板递归调用机制支持的一种编程范式。</li><li>C++中以对象和类型作为整个程序的核心，在对象方面，时刻注意对象创建和析构的成本，例如有一个很常用的(具名)返回值优化((N)RVO);<br>在类型方面，有运行时类型信息(RTTI)等技术作为C++类型技术的支撑。</li><li>函数重载：C++允许拥有不同变量但具有相同函数名的函数(函数重载的编译器实现方式、函数重载和(主)模板特化的区别都曾考过)。</li><li>异常：以catch、throw、try等关键字支持的一种机制。</li><li>名字空间：namespace，可以避免和减少命名冲突且让代码具有更强的可读性。</li><li>谓词用法：通常以bool函数或仿函数(functor)或lambda函数的形式，出现在STL的大多数算法的第三个元素。</li></ol></li><li>常见关键字(操作符)特性：<ol><li>auto：在C中，auto代表自动类型通常都可省略；而在C++11新标准中，则起到一种“动态类型”的作用——通常在自动类型推导和decltype搭配使用。</li><li>空指针：在C中常以NULL代表空指针，在C++中根据新标准用nullptr来代表空指针。</li><li>&amp;: 在C中仅代表取某个左值(lvalue)的地址，在C++中还可以表示引用(别名)。</li><li>&amp;&amp;：在C中仅能表示逻辑与，在C++中还可以表示右值引用。</li><li>[]：在C中仅能表示下标操作符，在C++中还可以表示lambda函数的捕捉列表。</li><li>{}：在C中仅能用于数组的初始化，在C++中由于引入了初始化列表(initializer_list)，可用于任何类型、容器等的初始化。</li><li>常量定义：C中常以define来定义常量，C++中用const来定义运行期常量，用constexpr来定义编译器常量。</li></ol></li><li>常用新特性：<ol><li>右值引用和move语义(太多内容，建议自查)。</li><li>基于范围的for循环(与python中的写法类似，常用于容器)。</li><li>基于auto——decltype的自动类型推导。</li><li>lambda函数(一种局部、匿名函数，高效方便地出现在需要局部、匿名语义的地方)。</li><li>标准规范后的多线程库。</li></ol></li></ol></li></ol><p><strong>问3：什么是面向对象（OOP）？</strong></p><p>答：面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。面向对象就是把现实问题抽象为对象，通过调用每个对象的属性或功能去解决问题。</p><p>对象<br>对象是由数据（描述事物的属性）和作用于数据的操作（体现事物的行为）组成的封装体，描述客观事物的一个实体，是构成系统的基本单元。</p><p>类<br>类是对一组有相同数据和相同操作的对象的定义，是对象的模板，其包含的方法和数据描述一组对象的共同行为和属性。类是在对象之上的抽象，对象则是类的具体化，是类的实例。类可有其子类，也可有其他类，形成类层次结构。1）类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。</p><p>2）类是一组具有相同属性和行为的对象的抽象。我们可以将类看做是创建对象<strong>蓝图</strong>，对象根据这个蓝图去具体实现某个东西。</p><p><strong>问4：什么是多态？</strong></p><p>答：多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态。</p><p><strong>问5：设计模式懂嘛，简单举个例子？</strong></p><p>答：设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>比如单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。将构造函数、析构函数、复制构造函数、赋值操作符声明为私有，即可实现单例模式</p><p>适用于：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p><p>比如工厂模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><p>适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p><strong>问8：const知道吗？解释其作用。</strong></p><p>答：</p><p>1.const 修饰类的成员变量，表示成员常量，不能被修改。</p><p>2.const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。</p><p>3.如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。</p><p>4.const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。</p><p>5.类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。。</p><p><strong>问12：解释下封装、继承和多态？</strong></p><p>答：</p><p><strong>一、封装：</strong></p><p>封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。封装(encapsulation)即信息隐蔽。它是指在确定系统的某一部分内容时，应考虑到其它部分的信息及联系都在这一部分的内部进行，外部各部分之间的信息联系应尽可能的少。</p><p>封装的意义在于保护或者防止代码（数据）被我们无意中破坏。</p><ul><li>public：对外公开，访问级别最高</li><li>protected：只对同一个包中的类或者子类公开</li><li>默认：只对同一个包中的类公开</li><li>private：不对外公开，只能在对象内部访问，访问级别最低</li></ul><p><strong>二、继承：</strong></p><p>让某个类型的对象获得另一个类型的对象的属性和方法。继承就是<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB&spm=1001.2101.3001.7020">子类继承父类</a>的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>继承主要实现<strong>重用代码</strong>，节省开发时间。</p><p>子类可以继承父类的一些东西。</p><p><strong>三、多态</strong></p><p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。多态：对于同一个行为，不同的子类对象具有不同的表现形式。多态存在的3个条件：<br>1）继承 2）重写 3）父类引用指向子类对象。</p><p><strong>问15：常用的排序算法有哪些？简单描述几个排序算法的优缺点？</strong></p><p>答：选择、冒泡、快速、**、希尔、归并、堆排等。</p><p>1.快排：是冒泡排序的一种改进。</p><p>优点：快，数据移动少</p><p>缺点：稳定性不足</p><p>2.归并：分治法排序，稳定的排序算法，一般用于对总体无序，但局部有序的数列。</p><p>优点：效率高O(n)，稳定</p><p>缺点：比较占用内存</p><p><strong>问16：new和malloc的区别？</strong></p><p>答：</p><p>1、new是关键字，需要编译器支持；malloc是库函数，需要头文件支持。</p><p>2、new申请内存无需指定内存大小，编译器会根据类型信息自行计算。除此之外，new会调用构造函数。malloc必须由我们计算需要申请的字节数，需要显式指出所需内存的尺寸，并且返回后强行转换为实际类型的指针。而且malloc只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值是随机的。</p><p>3、new可以重载，malloc不可以重载。</p><p>4、new是关键字，malloc是库函数，new的效率高于malloc。<br>new和malloc都可用于申请动态内存和释放内存。对于<strong>非内部数据类型</strong>的对象而言，光用maloc&#x2F;free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc&#x2F;free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc&#x2F;free。 C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。所以说new的效率高于malloc。</p><p>5、new出来的指针是直接带类型信息的。而malloc返回的都是void指针。</p><p><strong>问18：同步IO和异步IO的区别？</strong></p><p>答：</p><p><strong>A. 同步</strong></p><p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p><p>按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。</p><p>但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。</p><p>最常见的例子就是 SendMessage。</p><p>该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。</p><p>当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。</p><p><strong>B. 异步</strong></p><p>异步的概念和同步相对。</p><p>当一个异步过程调用发出后，调用者不会立刻得到结果。</p><p>实际处理这个调用的部件是在调用发出后，通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><h5 id="C-是不是类型安全的？"><a href="#C-是不是类型安全的？" class="headerlink" title="C++是不是类型安全的？"></a>C++是不是类型安全的？</h5><p>答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。</p><h5 id="main-函数执行以前，还会执行什么代码？"><a href="#main-函数执行以前，还会执行什么代码？" class="headerlink" title="main 函数执行以前，还会执行什么代码？"></a>main 函数执行以前，还会执行什么代码？</h5><p>答案：全局对象的构造函数会在main 函数之前执行。</p><p><strong>请说出const与#define 相比，有何优点？</strong><br>答案：</p><p>const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</p><p>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</p><p>2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p><h5 id="vector的reserve和capacity的区别"><a href="#vector的reserve和capacity的区别" class="headerlink" title="vector的reserve和capacity的区别?"></a>vector的reserve和capacity的区别?</h5><p>答：reserve()用于让容器预留空间，避免再次内存分配；capacity() 返回在重新进行内存分配以前所能容纳的元素数量。</p>]]></content>
    
    
    <categories>
      
      <category>八股面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端/移动端面经</title>
    <link href="/2024/05/09/%E5%89%8D%E7%AB%AF%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/05/09/%E5%89%8D%E7%AB%AF%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>cookie</strong></p><p>cookie其实就是一些数据信息，类型为“<strong>小型文本文件</strong>”，存储于电脑上的文本文件中。游览器保存了我们的cookie，里面记录了一些信息。当我们打开一个网站时，如果这个网站我们曾经登录过，那么当我们再次打开网站时，发现就不需要再次登录了，而是直接进入了首页。</p><p>（名字、值、可访问目录、有效时间、大小）</p><p> cookie有2种存储方式，一种是会话性，一种是持久性。（可以人为设置）</p><p><strong>session和cookie的区别</strong></p><p><strong>2.1、</strong>保存的位置不同<br>cookie保存在浏览器端，session保存在服务端。<br><strong>2.2、</strong>使用方式不同<br>cookie如果在浏览器端对cookie进行设置对应的时间，则cookie保存在本地硬盘中，此时如果没有过期，则就可以使用，如果过期则就删除。如果没有对cookie设置时间，则默认关闭浏览器，则cookie就会删除。<br>session：我们在请求中，如果发送的请求中存在sessionId，则就会找到对应的session对象，如果不存在sessionId,则在服务器端就会创建一个session对象，并且将sessionId返回给浏览器，可以将其放到cookie中，进行传输，如果浏览器不支持cookie，则应该将其通过encodeURL(sessionID)进行调用，然后放到url中。<br><strong>2.3、</strong>存储内容不同：cookie只能存储字符串，而session存储结构类似于hashtable的结构，可以存放任何类型。<br><strong>2.4</strong>、存储大小：&#96;&#96;cookie最多可以存放4k大小的内容，session则没有限制。<br><strong>2.5、</strong>session的安全性要高于cooKie<br><strong>2.6、</strong>cookie的session的应用场景：cookie可以用来保存用户的登陆信息，如果删除cookie则下一次用户仍需要重新登录<br>session就类似于我们拿到钥匙去开锁，拿到的就是我们个人的信息，一般我们可以在session中存放个人的信息或者购物车的信息。<br><strong>2.7、</strong>session和cookie的弊端：cookie的大小受限制，cookie不安全，如果用户禁用cookie则无法使用cookie。如果过多的依赖session，当很多用户同时登陆的时候，此时服务器压力过大。sessionId存放在cookie中，此时如果对于一些浏览器不支持cookie，此时还需要改写代码，将sessionID放到url中，也是不安全。</p><p><strong>localstorage和sessionstorage的区别</strong></p><p>1、localStorage存储在硬盘里，sessionStorage存储在内存里；</p><p>2、数据大小不同；</p><p>3、localStorage的生命周期是永久的，除非主动删除，sessionStorage的生命周期是临时的，当关闭当前窗口或标签页，数据就会被清空；</p><p>4、localStorage可以跨页面使用，sessionStorage只能在当前窗口使用。</p><p><strong>css选择器</strong></p><p>1.！important 优先级10000<br>2.内联选择器 优先级1000<br>3.ID选择器 优先级100<br>4.类别选择器 优先级10<br>5.属性选择器 优先级10<br>6.伪类 优先级10<br>7.元素选择器 优先级1<br>8.通配符选择器 优先级0<br>9.继承选择器 没有优先级</p><p>1、标签选择器：**标签名{css属性名：属性值}**通过标签名找到页面中的这类标签，设置样式</p><p>2、类选择器： **.类名{css属性名：属性值；}**通过类名找到页面中的带有这个类名的标签，设置样式</p><p>3、id选择器：**#id属性值{css属性名：属性值;}**通过id属性值，找到页面中带有这个id属性值的标签，设置样式</p><p>4、通配符选择器：***{css属性名：属性值}**找到页面中所有的标签，然后设置样式（开发中应用最少）</p><p><strong>css权重</strong></p><p>1.从0开始，一个<a href="https://so.csdn.net/so/search?q=%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F&spm=1001.2101.3001.7020">行内样式</a>+1000<br>2.一个id选择器+100<br>3.一个属性选择器、class或者伪类+10<br>4.一个元素选择器，或者伪元素+1，通配符+0。</p><p>权重决定了你css规则怎样被浏览器解析直到生效。“css权重关系到你的css规则是怎样显示的”。 当很多的样式被应用到某一个元素上时，权重是一个决定哪种样式生效，或者是优先级的过程。</p><p>!important &gt; 行内样式 &gt; 内联样式 and 外联样式</p><p><strong>css盒模型</strong></p><p>html中的各个元素都类似一个一个的盒子里面的物品，但是却叫做css盒模型，是因为css盒模型像一个盒子，把各种html元素包起来，将html元素进行封装，以便于网页布局与排版。</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240513102005071.png" alt="image-20240513102005071" style="zoom: 33%;" /><pre><code class="hljs">    1，上面图中蓝色方框指的是html元素，也是内容部分context，可以是一张图片、一个h1标题、一个表格、一个表单等。但是他的大小并不一定是100×100，而是可以修改的。属性width和height用于修改内容部分的大小。    2，绿色部分，也就是padding部分，指的是内边距，是元素内容与其最近一层束缚框的距离，类似于在一个方格里写字我们写在方格的中间，而与边框保持一定距离一样。    3，浅橘色部分，也就是border部分，指的是这个边框的宽度，我们常见的就是宽度为1，也就是一条线。    4，深橘色部分，也就是margin部分，也叫边缘部分，类似于人与人之间保持一定的距离一样，他的作用是保证html元素之间的距离，比如网页上的两种图片需要保持一定的间距才显得好看。    5，padding，border，margin实际上是每个html元素都存在的css属性。他们可以对元素的上下左右四个方向进行限制。    6，当存在盒子里嵌套盒子时，也就是html的标签嵌套时，里面的元素默认以左上角作为停靠点。    7，盒子模型可用简记为：4个矩形套娃。</code></pre><p><strong>css 有哪几种定位</strong></p><p><strong>1、</strong>静态定位：默认值。（没有指定定位方式时）按照文档的书写布局自动分配在一个合适的地方，用margin改变位置。</p><p><strong>2、</strong>相对定位：脱离正常的文档流，但是其在文档流中的位置依然存在，视觉上相对原来的位置有移动。（设置left、top等值）</p><p><strong>3、</strong>绝对定位：默认情况下依赖浏览器的左上角为定位基准;如果绝对定位的元素存在父、祖先元素且存在相对定位的时候该元素将依赖具备相对定位的元素来进行定位，而不是左上角。（设置top、right、bottom、left这些偏移值，相对于 static 定位以外的第一个父元素进行定位）在没有父元素的条件下，它的参照为body，该方式脱离文档流</p><p><strong>4、</strong>固定定位：生成绝对定位的元素，相对于浏览器窗口进行定位。只需设置它相对于各个方向的偏移值，就可以将该元素固定在页面固定的位置，通常用来显示一些提示信息，脱离文档流；</p><h5 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h5><ol><li>块级元素会独占一行，从上向下顺序排列。</li><li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。</li></ol><p><strong>12. 如果制作一个访问量很大的网站，对css，js和图片应该怎么处理?</strong></p><p>方法1：资源文件按模块进行放置，有利于团队开发</p><p>方法2：图片尽量采取聚合技术</p><p>方法3：精简压缩css和js文件，减少文件大小</p><p>方法4：类库、媒体使用CDN加速，减轻服务器压力</p><p><strong>解释jsonp的原理</strong></p><p>JSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p><p><strong>JS怎么创建一个类?</strong></p><p>方式1 : var obj &#x3D; new Object();</p><p>方式2 : var obj &#x3D; {};</p><p><strong>ajax原理，什么是同步异步(主观题，答案不唯一)?</strong></p><p>Ajax的工作原理：相当于在用户和服务器之间加了—个中间层，使用户操作与服务器响应异步化。这样把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理，减轻服务器和带宽的负担，从而达到节约ISP的空间及带宽租用成本的目的。</p><p><strong>xml和json</strong></p><p>json相比xml可读性和可扩张性好、编码及解码难度较低、在数据交互中带宽占用少，并且在当下是最流行的数据交互格式。</p><p><strong>css怎么清除浮动</strong></p><p>1、给父元素单独定义高度</p><p>2、在标签结尾处(前)加空标签并设置<code>clear:both;</code></p><p>3、父元素div定义 伪元素:after</p><p>4、父元素定义 <code>overflow:hidden;</code></p><p>5、父元素定义 <code>overflow:auto;</code></p><p><strong>浮动的作用</strong>：可以让多个块级元素一行内排列显示。浮动可以改变元素标签默认的排列方式。</p><p><code>float</code> 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。</p><p><strong>js数据类型</strong></p><p>未定义 (Undefined)，空 (Null)，数字 (Number)，字符串 (String)，布尔值 (Boolean)，符号 (Symbol)，任意大整数 (BigInt)，对象 (Object)。</p><p> <strong>js 的作用域链</strong></p><p>各个作用域的嵌套关系组成一条作用域链。</p><p>作用域链主要是进行标识符（变量和函数）的查询，标识符解析就是沿着作用域链一级一级的搜索标识符的过程，而作用域链就是保证对变量和函数的有序访问。<br>（1）如果自身作用域中声明该变量，则无需使用作用域链<br>在上面的例子中，如果要在 bar 函数中查询变量 a ，则直接使用 LHS 查询，赋值为 100 即可。<br>（2）如果自身作用域中未声明该变量，则需要使用作用域链进行查找</p><p><strong>js 的作用域，块级作用域，函数作用域</strong></p><p>（由于 JavaScript 存在变量提升这种特性，从而导致很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷，这种设计缺陷带来的问题可以去看看JS变量和函数提升。所以 ES6 通过引入块级作用域并配合 let、const 关键字来避开了这种设计缺陷，但是由于 JavaScript 需要向下兼容，所以变量提升在相当长一段时间内还会继续存在。）</p><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。在 JS 中作用域分为全局作用域和函数作用域，另外函数作用域可以互相嵌套。（ES6增加了块级作用域）</p><p>1、全局作用域：全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</p><p>2、函数作用域：函数作用域就是在函数内部定义的变量或函数，并且定义的变量或函数只能在函数内部被访问，函数执行结束后，函数内部定义的变量就会被销毁。</p><p>3、块级作用域：ES6 中给 JavaScript 新增了块级作用域</p><ul><li><p>块级作用域由<code>&#123;&#125;</code>包括，<code>if</code>语句和<code>for</code>语句里面的<code>&#123;&#125;</code>都属于块级作用域</p></li><li><p><code>var</code>定义的变量没有块级作用域概念，可以跨块级作用域访问</p></li><li><p><code>let</code>和<code>const</code>定义的变量只能在块级作用域里访问</p><p>块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现的，通过两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。</p></li></ul><p><strong>同源和跨域，跨域问题怎么解决</strong></p><p><strong>1、</strong>同源策略：它是浏览器最核心也最基本的安全功能。如果缺少了同源策略，浏览器很容易受到 XSS、 CSFR 等攻击。同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p><p><strong>2、</strong>跨域：当浏览器中一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。（什么情况下触发同源策略）</p><p>（1）CORS技术（跨源资源共享）：服务器在返回响应报文的时候，在响应头中设置一个允许的header</p><p>（2）原生<a href="https://so.csdn.net/so/search?q=jsonp&spm=1001.2101.3001.7020">jsonp</a>：通过动态创建script标签,通过script标签的src,向一个不同源的接口发送一个get请求（jsonp不支持post）</p><ul><li>获取客户端发送过来的回调函数的名字</li><li>得到要通过JSONP形式发送给客户端的数据</li><li>根据前两步得到的数据，拼接出一一个函数调用的字符串</li><li>把上一步拼接得到的字符串，响应给客户端的<code>&lt;script&gt;</code>标签进行解析执行</li></ul><p>具有局限性，不安全，可能会受到XSS攻击；只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 Javascript 调用的问题</p><p>（3）jQuery中的jsonp：设置dataType为jsonp，<a href="https://so.csdn.net/so/search?q=jq&spm=1001.2101.3001.7020">jq</a>会自动动态帮我们创建一个script标签，将url放到src属性中。<em>细节注意点</em>：jq使用jsonp不需要自己设置callback，jq会自动帮我们发送callback参数，参数值就是jq的success回调函数</p><p>（4）浏览器设置跨域：通过修改一些设置，让被设置的浏览器没有同源的限制,自然可以实现跨域</p><p><strong>PNG格式和JPG格式的区别</strong></p><p>1、JPG 使用的是有损压缩——这意味着当图像变小时，图像中的某些数据会被永久删除。从长远来看，这可能会影响文件的质量，因为每次编辑和保存文件时，都会丢失更多数据。<br>PNG 使用无损压缩。这意味着压缩图像时不会丢失任何数据——无论编辑保存文件多少次，质量都保持不变。图像不会变得模糊或扭曲。</p><p>2、最好以 PNG 格式创建屏幕截图，这是几乎所有屏幕截图工具的默认设置。手机端一般会自动将屏幕截图保存为 PNG 格式。主要是因为屏幕截图一般包含具有清晰对比度的精确直线和没有颜色渐变的单色区域。这些都是JPG 格式的主要弱点。</p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240513111239223.png" alt="image-20240513111239223" style="zoom: 67%;" /><p>JPG适合用于照片，在风景或人物图片中几乎看不到压缩伪像。由于尺寸小，适合在网站中使用和网络传输。PNG适用于所有包含锐边和纯色的图形。用于保存屏幕截图、图标和需要透明背景的图片。</p><p>协商缓存和强缓存</p><p><strong>懒加载的原理和你是怎么实现的</strong></p><p>1、对于页面有很多静态资源的情况下（比如网商购物页面），为了节省用户流量和提高页面性能，可以在用户浏览到当前资源的时候，再对资源进行请求和加载。</p><p>2、原理：监听onscroll事件判断资源位置</p><p>首先为所有懒加载的静态资源添加自定义属性字段，比如如果是图片，可以指定data-src为真实的图片地址，src指向loading的图片。<br>然后当资源进入视口的时候，将src属性值替换成data-src的值。<br>可以使用元素的getBoundingRect().top判断是否在视口内，也可以使用元素距离文档顶部的距离offsetTop和scrollTop是否小于视口高度来判断：</p><p>React setState之后的流程</p><p><strong>有什么办法实现深拷贝？</strong></p><p>1、浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是指向内存的地址 ，所以如果其中一个对象改变了这个引用类型的值，就会影响到另一个对象。<br>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。<br>2、方法：递归调用、lodash函数库（**lodash.cloneDeep()**）实现深拷贝、通过js的内置对象JSON来进行深拷贝、通过jQuery的extend方法实现深拷贝、Object.assign()拷贝</p><p><strong>怎么调试 JS 代码</strong></p><p>1、直接在js代码中加入断点进行调试</p><p>2、在事件监听器上设置断点</p><p>3、在DOM节点中设置断点</p><p>（下一步、跳过一些代码、进入函数、跳出函数、跳到下一个断点）</p><p>4、使用vs code（安装某些插件）</p><p>web安全问题，答了（xss、csrf），怎么防御攻击</p><p>\1. 地图展示为什么不用 Google<br>\2. 小程序为什么不使用框架<br>\3. 没有学 react 吗<br><strong>前后端分离是什么</strong></p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240513113123476.png" alt="image-20240513113123476" style="zoom:67%;" /><p>1、”前”特指浏览器端(或客户端)，直接呈现给用户的；后端是服务器端，处理业务逻辑和数据，不呈现给用户（JSP不是前端技术）</p><p>2、静态资源和服务(实现接口的业务逻辑)，在开发阶段就分离开发，而部署阶段分离部署在不同服务器上，算是严格意义上的前后端分离。</p><p>3、前端人员和后端人员约定好接口后，前端人员彻底不用再关心业务处理是怎么回事，他只需要把界面做好就可以了，后端人员也不用再关系前端界面是什么样的，他只需要做好业务逻辑处理即可。服务的切离，代码管理，服务部署也都独立出来分别管理，系统的灵活性也获得了极大的提升。</p><p>4、最核心的就是无论你后端换了什么语言，换了什么人去编写，换了什么样的服务器，只要你们定义的一个接口规则不变，然后不会影响到用户的使用，数据的一个展示。同时反过来也一样，无论你前端换了什么UI框架，欸，我今天用easyui，明天我用layui，后天我用bootstrap，你也能够根据定义的接口文档去展示相关数据和效果，那么就是前后端分离。</p><p><strong>闭包是什么</strong></p><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>1.让外部访问函数内部变量变成可能</p><p>2.变量会常驻在内存中</p><p>3.可以避免使用全局变量,防止全局变量污染;</p><p>4.可能会造成<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&spm=1001.2101.3001.7020">内存泄漏</a>或溢出。</p><p><strong>闭包要注意什么</strong></p><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，<strong>在退出函数之前，将不使用的局部变量全部删除。</strong></p><p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><p>\12. this 指向<br>\13. var、const、let<br>\14.</p><p> <strong>flex 布局</strong></p><p>flex是Flexible Box的缩写，意为弹性布局，用来为<a href="https://so.csdn.net/so/search?q=%E7%9B%92%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">盒模型</a>提供最大的灵活性</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240513135451485.png" alt="image-20240513135451485"></p><p>（主轴方向、如何换行、如何对齐、项目放大、缩小比例）</p><p><strong>CSS引入的方式有哪些?link和@import的区别是?</strong></p><p>内联 内嵌 外链 导入<br>区别 ：同时加载<br>前者无兼容性，后者CSS2.1以下浏览器不支持<br>Link 支持使用javascript改变样式，后者不可</p><p><strong>XSS</strong>(反射型、存储型、DOM型)</p><ul><li>攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。</li><li>诱使受害者打开受到攻击的服务器URL。</li><li>受害者在Web浏览器中打开URL，恶意脚本执行。</li></ul><p>防范：</p><p>（1）编码：对用户输入的数据进行HTML Entity编码</p><p>（2）过滤：移除用户上传的DOM属性，如onerror等，移除用户上传的style节点，script节点，iframe节点等。</p><p>（3）校正：避免直接对HTML Entity编码，使用DOM Prase转换，校正不配对的DOM标签。</p><p><strong>CSRF</strong></p><p>跨站请求伪造</p><p>攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账…造成的问题包括：个人隐私泄露以及财产安全。</p><ol><li>登录受信任网站A，并在本地生成Cookie</li><li>在不登出A的情况下，访问危险网站B</li></ol><p><strong>Node.js的适用场景？</strong></p><p>高并发、聊天、实时消息推送</p><p> <strong>404、500、301 分别是什么</strong></p><p>100-199 用于指定客户端应相应的某些动作。</p><p>   200-299 用于表示请求成功。</p><p>   300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</p><p>   400-499 用于指出客户端的错误。400    1、语义有误，当前请求无法被服务器理解。401   当前请求需要用户验证 403  服务器已经理解请求，但是拒绝执行它。</p><p>   500-599 用于支持服务器错误。 503 – 服务不可用</p><p>301：永久移动（网页移动到新的位置）</p><p>302：临时移动</p><p>400：错误请求（服务器不理解请求的语法）</p><p>403：服务器拒绝请求</p><p>404：服务器找不到请求的网页</p><p>500：服务器内部错误，无法完成请求</p><p>502：错误网关</p><p><strong>几种CSS布局方式及其特点</strong>。 </p><p>答案：常见的CSS布局方式包括浮动、定位、弹性布局和网格布局。</p><p> <strong>404、500 错误如何检查</strong></p><p>\21. 临时重定向是什么，二者区别<br>\22. http 2.0<br>\23. React 没学过吗<br>\24. vue 如何实现响应式<br>\25. v-if 和 v-show 区别<br>\26. 组件间通信方式<br>\27. 性能优化（使用异步请求)<br>\28. 给请求排序</p><p><strong>框架 vue和react的异同</strong></p><p>一、同</p><p>①都使用虚拟dom。<br>②提供了响应式和组件化的视图组件。<br>③把注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</p><p>二、异</p><p>vue：1、渐进式框架、自底向上增量开发</p><p>​          2、可以在任意其他类型的项目中使用，使用成本较低，更灵活，主张较弱</p><p>3、易用（使用成本低），灵活（生态系统完善，适用于任何规模的项目），高效（体积小，优化好，性能好）</p><p>react：主张是函数式编程的理念， 实现了前端界面的高性能高效率开发，react很擅长处理组件化的页面。在 React 中，所有的组件的渲染功能都依靠 JSX，它是JavaScript的语法扩展，它在创建UI组件和调试时非常简单有用。</p><p>三、总结</p><p>1、React：整体是函数式的思想，在react中，是单向数据流，推崇结合immutable来实现数据不可变。<br>Vue：的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p><p>2、React：思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等。<br>Vue：把html，css，js组合到一起，用各自的处理方式，Vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。</p><p>3、当组件的状态发生变化时，React的机制会触发整个组件树的重新呈现。您可能需要使用额外的属性来避免不必要地重新渲染子组件。虽然Vue的重新渲染功能是开箱即用的，但Vue提供了优化的重新渲染，其中系统在渲染过程中跟踪依赖关系并相应地工作。重新渲染是Vue最显着的特征，也使其成为全世界开发人员广泛接受的框架。</p><p>4、react是类式的写法，api很少，而Vue是声明式的写法，通过传入各种options，api和参数都很多。所以react结合typescript更容易一起写，Vue稍微复杂。</p><p>手写防抖节流</p><p><strong>浏览器性能优化策略</strong></p><p>一、感知性能优化（loading图标或者骨架屏）</p><p>如果一个页面的加载时间很长，我们也可以通过一些方式让用户觉得没有那么慢。</p><p>二、HTML优化</p><p>1、HTML代码压缩，将注释、空格和新行从生产文件中删除。减少HTML的大小，加快网站的页面加载时间，并显著减少用户的下载时间。 </p><p>2、删除不必要的注释</p><p>3、删除不必要的属性： <code>type=&quot;text/javascript&quot;</code> or <code>type=&quot;text/css&quot;</code> </p><p>4、使用语义化标签<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240513150309276.png" alt="image-20240513150309276" style="zoom:33%;" /></p><p>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</p><p>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</p><p>方便其他设备解析，如盲人阅读器根据语义渲染网页</p><p>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。</p><p>5、减少iframe数量</p><p>6、削减DOM数量和层级数量</p><p>7、减少HTTP请求次数（将多个 CSS 和 JavaScript 文件合并为一个文件）</p><p>三、JS优化</p><p>1、<script>标签尽量尽可能放到<body>标签的底部。</p><p>2、尽量减少 DOM 操作的次数和复杂度，可以提高页面的响应速度和性能。</p><p>3、删除重复的脚本</p><p>4、节流与防抖：日常开发过程中，滚动事件做复杂计算频繁调用回调函数很可能会造成页面的卡顿，这时候我们更希望把多次计算合并成一次，只操作一个精确点，JS把这种方式称为debounce（防抖）和throttle（节流）。</p><p>5、</p><p>四、CSS优化</p><p>1、少用@import（影响浏览器的并行下载、导致下载顺序紊乱）</p><p>2、避免！important选择器（破坏了样式表中固有的级联规则、尽量靠近html或body元素）</p><p>3、不在id选择器之前嵌套其他的选择器</p><p>4、压缩CSS文件</p><p>5、CSS层级嵌套尽量不超过三层</p><p>五、图片优化</p><p>1、根据实际需要压缩照片</p><p>2、小图片引入雪碧图</p><p>3、图片懒加载</p><p><strong>React</strong>中的组件生命周期有哪些阶段？ 答案：在React中，组件的生命周期分为三个阶段：挂载阶段、更新阶段和卸载阶段。</p><p><strong>vue 生命周期</strong></p><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p><p>什么是事件代理</p><p>vue2和vue3响应式的区别</p><p>vue2组件间通信方式</p>]]></content>
    
    
    <categories>
      
      <category>八股面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS刷题记录</title>
    <link href="/2024/05/04/DFS%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/05/04/DFS%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>DFS：广度优先搜索</p><span id="more"></span><h3 id="一、分糖果"><a href="#一、分糖果" class="headerlink" title="一、分糖果"></a>一、分糖果</h3><p>​       假如有有两种糖果，每种分别有m和q个，要分给k个人，并且每个人手上的糖果不少于2个不多于5个，一共有多少种分法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> res;<br><span class="hljs-type">int</span> k,m,q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(n==k)<br>    <span class="hljs-keyword">if</span>(a==m&amp;&amp;b==q)  res++;  <span class="hljs-comment">//分好了</span><br>    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//n若已达到k，不管有没有分好都需要return</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=q;j++)<br>      <span class="hljs-keyword">if</span>(i+j&gt;=<span class="hljs-number">2</span>&amp;&amp;i+j&lt;=<span class="hljs-number">5</span>)<br>        <span class="hljs-built_in">dfs</span>(n+<span class="hljs-number">1</span>,a+i,b+j);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cin&gt;&gt;k&gt;&gt;m&gt;&gt;q;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法详解+图示（附优化版）</title>
    <link href="/2024/04/25/KMP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3+%E5%9B%BE%E7%A4%BA%EF%BC%88%E9%99%84%E4%BC%98%E5%8C%96%E7%89%88%EF%BC%89/"/>
    <url>/2024/04/25/KMP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3+%E5%9B%BE%E7%A4%BA%EF%BC%88%E9%99%84%E4%BC%98%E5%8C%96%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、KMP算法的意义"><a href="#一、KMP算法的意义" class="headerlink" title="一、KMP算法的意义"></a>一、KMP算法的意义</h3><p>​在求解这样的算法问题时：已知两个字符串s1和s2，其中s2是s1的字串，请找到s2在s1中的位置。传统的寻找方法即暴力解法：分别从两个字串的第一个字符开始找起，若可以匹配就继续下一个字符；若匹配失败，s1回溯到第二个字符，s2回溯到第一个字符，依此类推……</p><p>​暴力解法在字串长度过大时往往时间复杂度很高，而其主要原因是因为回溯的次数太多，而KMP算法的作用就是用已知的信息量去尽可能减少回溯次数，达到简洁且迅速的效果。</p><h3 id="二、KMP算法的步骤"><a href="#二、KMP算法的步骤" class="headerlink" title="二、KMP算法的步骤"></a>二、KMP算法的步骤</h3><h4 id="1-计算字符串中每个位置之前字串的最长相等前后缀长度"><a href="#1-计算字符串中每个位置之前字串的最长相等前后缀长度" class="headerlink" title="1.计算字符串中每个位置之前字串的最长相等前后缀长度"></a>1.计算字符串中每个位置之前字串的最长相等前后缀长度</h4><p>（1）最长相等前后缀的概念</p><p>​已知一个字符串abaaba,它的前缀字串和后缀字串分别为：</p><p>前缀：a,ab,<strong>aba</strong>,abaa,abaab;</p><p>后缀：a,ba,<strong>aba</strong>,aaba,baaba;</p><p>​那么很明显，aba是它的最长相等前后缀，即这个字符串的最长相等前后缀长度为3。</p><p>（2）next[n]数组</p><p>​对于字符串abaabac，我们想要用数组next[n]中的元素next[i]来保存字符串第i个字符前的字串的最长相等前后缀的长度。</p><p>​首先，我们规定next[0]&#x3D;-1（前面没有字串），next[1]&#x3D;0(字串没有前后缀)。那么就可以得到next[n]的值：</p><p>​ abaabac</p><p>next[0]  [1] [2]      [3]     [4]      [5]     [6]</p><p>​    -1    0    0    1    1    2        3</p><h4 id="2-根据next数组，对字串进行匹配"><a href="#2-根据next数组，对字串进行匹配" class="headerlink" title="2.根据next数组，对字串进行匹配"></a>2.根据next数组，对字串进行匹配</h4><p>​创建如下图所示的两个字符串。</p><p>​已知在进行前六个字符的匹配时，由于都能够匹配成功，因此箭头同步向右移动。当匹配到如图所示的位置时，匹配失败了。如果按照暴力解法，那么上面的字符串应该从第一个b开始匹配，而子串需要从头匹配。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240425170716134.png" alt="image-20240425170716134"></p><p>​而KMP算法则利用上一步我们求解的next数组，已知子串中字符<strong>c</strong>的位置是6，而<strong>next[6]&#x3D;3</strong>。因此下一次匹配时，我们直接移动子串，使得子串位置为<strong>3</strong>的字符<strong>a</strong>对准箭头所在的地方，如图。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240425171406127.png" alt="image-20240425171406127"></p><p>​接下来让我们理解一下这一步的原理是什么。我会讲解地通俗一点（可能我的理解比较浅显，但是这个思路是可以弄清楚这个算法的）。</p><p>​我们知道KMP算法的作用是要减少回溯的次数，那么如何减少呢？当我们已经走到图一的位置时，我们很容易发现按照暴力方法很浪费时间，因为很明显直接按图二移动是最方便快捷的。由于字符串的匹配不可能每次都让我们用眼睛看到，因此我们需要将信息存储在数组里，需要的时候就可以使用。而next数组就是存储这个重要信息的数组。比如在图一的位置，next数组可以告诉程序，在已知匹配的字符串中，前三位字符和后三位字符是相等的。而此时只有最后一位是不匹配的，因此，我们只需要把前三位平移过来，那么就可以得到图二的结果：有三位字符是匹配的，然后我们继续判断下一位是否和p匹配。既然最大相等前后缀字符串的长度为3，那么对应的，箭头就应该指向子串位置为3的字符（从0计）。</p><p>​以此类推，由于next[3]&#x3D;1,那么相应的，箭头应该指向第二个字符b。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240425172526743.png" alt="image-20240425172526743"></p><p>​接下来，聪明的你应该知道，箭头应该指向a了。可是这时候仍然是不匹配的，而且next[0]&#x3D;-1，这时候应该怎么办呢？很简单，这时候应该将字符串的箭头向右移动了，而子串的箭头位置不变，因为它已经指向字串的第0个字符了。</p><h3 id="三、KMP算法的代码实现"><a href="#三、KMP算法的代码实现" class="headerlink" title="三、KMP算法的代码实现"></a>三、KMP算法的代码实现</h3><h4 id="1-计算next数组"><a href="#1-计算next数组" class="headerlink" title="1.计算next数组"></a>1.计算next数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> next[])</span></span><br><span class="hljs-function"></span>&#123;<br>    next[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span>||s[i]==s[k])&#123;<br>            i++,k++;<br>            next[i]=k;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            k=next[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这个函数真的很不好理解。如果让我直接去想这个代码我是肯定想不到的，因此只能就着代码理清思路，这样做题的时候不至于忘记。</p><p>​首先，由于k的初始值是-1，所以一定会进入if函数里，这样一来，next[1]就被赋为0了。</p><p>​当k&#x3D;-1或者s[i]&#x3D;s[k]的时候，会将i和k同时右移。我们先分析，什么时候k&#x3D;-1呢？只有上一次循环时k&#x3D;0，并且s[0]!&#x3D;s[i]时，在k&#x3D;next[k]这个公式里，才会将k又赋为-1。故而此时，i+1前并无相等前后缀，也就又将next[i+1]赋为0。接着，又会判断s[i+1]与s[0]是否相等，如果相等，则i+2前最大相等前后缀长度就为1了。</p><p>​若前面已经有相等前后缀，此时s[i]&#x3D;s[k]，那么相当于相等前后缀的延长，因此s和k会同时后移观察下一位是否也相等。</p><p>​比较复杂的情况如下图（理解k&#x3D;next[k]）</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240425211350229.png" alt="image-20240425211350229"></p><p>​如图是一串字符串，下标i和next[i]的值分别在其上下标出。在i&#x3D;6，k&#x3D;3之前，可以发现最大前后缀是3，而此时s[i]&#x3D;s[k]不相等。而这个函数的关键之处：k&#x3D;next[k]，将k的值改变成了1（next[3]&#x3D;1)。我们可以发现，如果将k和i分别向前移一位，此时k&#x3D;0，i&#x3D;5，而s[i]的值刚好等于s[k]。这并不是巧合。因为i&#x3D;6之前最大前后缀长度为3，也就是说明字符串前三位和i&#x3D;6之前的三位是相等的。而下标i&#x3D;3之前的最大前后缀长度为1，也就是说明i&#x3D;0、i&#x3D;2、i&#x3D;3、i&#x3D;5这几个数的值也是相等的。所以现在我们向前回溯到，与i&#x3D;6不相等的那个下标（此处为3）之前的子串中的相等前后缀，它的长度对应的下标前的子串一定和i&#x3D;6前的某个后缀相等。然后我们继续比较该下标的值和i&#x3D;6处的值是否相等，以此类推。</p><p>​如果还是不太明白可以多试几个字符串多多验证几次，推导几遍，就会渐渐思路清晰。（其实我们会发现这个思想和前面讲到的KMP思想很类似）</p><p>​ps:while函数中之所以i&lt;s.size()-1，是因为每次都是先i++再赋值的。</p><h4 id="2-KMP算法的代码"><a href="#2-KMP算法的代码" class="headerlink" title="2.KMP算法的代码"></a>2.KMP算法的代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMPinit</span><span class="hljs-params">(string s,string p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> len=p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> next[len],i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">getnext</span>(p,next);<span class="hljs-comment">//求出next数组</span><br>    <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;len)&#123;<span class="hljs-comment">//跳出循环要么找完s字符串都没找到，要么已经找完了</span><br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||s[i]==s[j])&#123;<span class="hljs-comment">//根据图示理解</span><br>            i++,j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j=next[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;=len)&#123;<span class="hljs-comment">//如果跳出循环是因为已经匹配完毕，那么就可以返回位置了</span><br>        <span class="hljs-type">int</span> index=i-len;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//找不到匹配项</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、KMP代码的优化"><a href="#四、KMP代码的优化" class="headerlink" title="四、KMP代码的优化"></a>四、KMP代码的优化</h3><p>​假设子串为aaaaaab，并且字符串为aaaaaacccc。我们会发现b与c不匹配，接着便是前一位的a与c进行匹配，但是依旧不匹配，而紧接着会将前面的a依次与c匹配，得到的结果仍旧是不匹配，因此当next数组指向的字符和它本身相等时，便没有必要再匹配下去。</p><p>​所以我们可以把next函数做以下修正(KMP函数无需改变)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> next[])</span></span><br><span class="hljs-function"></span>&#123;<br>    next[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span>||s[i]==s[k])&#123;<br>            i++,k++;<br>            <span class="hljs-keyword">if</span>(s[i]!=s[k])<br>            next[i]=k;<br>            <span class="hljs-keyword">else</span><br>                next[i]=next[k];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            k=next[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考博客：CSDN（哈顿之光）</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为博客配置waline评论模块需要注意什么</title>
    <link href="/2024/04/22/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AEwaline%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88/"/>
    <url>/2024/04/22/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AEwaline%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>​想要在Github博客中部署一个评论模块有许多选择，其中waline是在valine的基础上衍化而来，因此功能也会更多。但是在跟着官方文档配置的时候需要注意一些问题，否则会一直出错😿……（如果你因fail to fetch这个错误而来，那真是找对人了）</p><span id="more"></span><p>​先附上官方教程文档：<a href="https://waline.js.org/guide/get-started/#vercel-%E9%83%A8%E7%BD%B2-%E6%9C%8D%E5%8A%A1%E7%AB%AF">快速上手 | Waline</a></p><p>​首先要注意的是在注册LeanCloud账号时最好注册国际版，这样比较方便。</p><h3 id="一、vercel部署部分"><a href="#一、vercel部署部分" class="headerlink" title="一、vercel部署部分"></a>一、vercel部署部分</h3><h5 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h5><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240422144225513.png" alt="image-20240422144225513"></p><p>如上图所示，首先需要点击Deploy然后进行登录，登陆完成之后，会显示这个界面：</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240422144718930.png" alt="image-20240422144718930"></p><p>这时我一脸蒙，于是就真的随便找了一个项目creat了（页面和教程不一样但我并未在意）……</p><p>其实应该退回到教程页，再点一遍deploy，就可以和教程一致了。</p><h5 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2.环境变量配置"></a>2.环境变量配置</h5><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240422145045708.png" alt="image-20240422145045708"></p><p>​第一次看这段话的时候我有点疑惑，加上这时候设置的界面和教程有细微差别，所以我的配置也出错了。如下图所示，正确的配置应该是KEY栏分别写入LEAN_ID<code>, </code>LEAN_KEY和LEAN_MASTER_KEY，Value栏分别写入它们三个的值。（需要add more新创建两个栏）</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240422145236754.png" alt="image-20240422145236754"></p><h5 id="3-获取服务端地址"><a href="#3-获取服务端地址" class="headerlink" title="3.获取服务端地址"></a>3.获取服务端地址</h5><p>​教程中写到，部署结束后点击visit后跳转到的网页的网址即是服务器地址，也就是后面的serverURL，在HTML文件部署的时候也需要用到。</p><p>​重点来了！！！！在我把所有东西全部部署结束，且保证绝对无误的情况下，虽然我的博客网页上已经展现出了评论的模块，我居然还是评论不了（会显示fail to fetch）……（此时心态已崩🤯）我反反复复找了很久的错误，翻看了视频教程下的评论，终于发现了和我一样错误的友友。他说原因是“<strong>完成后访问的visit地址和第二次在ver项目中打开的server地址不一样</strong>”。我反复琢磨了很久，因为我反复点开visit，这个网址一直不变啊。。。突然，一切都变了，某个瞬间当我点开visit时，它居然显示网页停止访问😨。我三分疑惑四分愤怒地又点开了很多次，终于它加载出来了，定睛一看网页的域名居然变了😇😇😇😇😇😇😇</p><p>​当我把变化后的域名代替先前的域名后，错误就解决了！</p><h3 id="二、HTML引入"><a href="#二、HTML引入" class="headerlink" title="二、HTML引入"></a>二、HTML引入</h3><h5 id="1-找到index-html"><a href="#1-找到index-html" class="headerlink" title="1.找到index.html"></a>1.找到index.html</h5><p>​（ps：不知道不同主题是否对这个配置文件名有影响，我所用的是fluid这个主题）</p><p>​这里我又犯错了，因为我发现.deploy_git和public文件夹下都有一个这样的文件。由于先前我知道了每次hexo clean后都会删掉public文件夹，因此我毅然决然地选择修改了.deploy_git里的文件。于是每次部署网页之后，我都惊奇地发现回到这个文件后我做的修改都离奇消失了。直到我在hexo d时仔细地看了一眼运行结果，发现它赫然写着delete  .deploy_git以及保留public，我的小脑都萎缩了🫠。</p><p>​因此结论就是，一定要<strong>修改public文件夹下的index.html文件</strong>，这样才能生效。</p><h5 id="2-如何修改"><a href="#2-如何修改" class="headerlink" title="2.如何修改"></a>2.如何修改</h5><p>​注意在修改的时候不要把教程文档的所有代码全部粘贴进html文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240422151514648.png" alt="image-20240422151514648"></p><p>​第一部分：head部分，只将中间的那一部分添加入自己html文件的head部分里。记得缩进一定要规范。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240422151659178.png" alt="image-20240422151659178"></p><p>​第二部分：body部分。我们在html文件中找到<body>后点开方便的符号就可以折叠，这样就可以找到body部分的末尾在哪里<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240422151922923.png" alt="image-20240422151922923"></p><p>而第二部分最好添加进body部分的最后面。由于我的文件里写道要把某部分保留在最后，因此这一部分代码我就放在那部分前面了。仍然要注意缩进的格式！但是因为我的文件中，body内的很多代码都没有缩进，因此这一部分代码我也没有缩进一格。</p><h3 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h3><h5 id="1-部署博客主题配置文件"><a href="#1-部署博客主题配置文件" class="headerlink" title="1.部署博客主题配置文件"></a>1.部署博客主题配置文件</h5><p>​在我配置评论功能的时候，不仅部署了html文件，还部署了yml文件。具体的部署要视各主题而定。因为主题部署文件可能并未默认开启评论功能，因此要去文件中找到“comment”部分，打开评论功能，并配置其他相应必要代码。</p><h5 id="2-重新创建项目"><a href="#2-重新创建项目" class="headerlink" title="2.重新创建项目"></a>2.重新创建项目</h5><p>​如果在第一次配置时出错了，想要再次配置，一定要先删掉之前的项目，删除方法如下图所示，点开Geberal下滑到最下面就可以删掉了。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240422152645310.png" alt="image-20240422152645310"></p><p>​但是仅仅在这里删掉是没有用的。还需要进入自己的GitHub网站，你会发现那里也创建了一个同名项目，需要将它也删除。</p><p>​（这个错误也硬控我半小时😾）</p><p>​如果跟着教程文档配置结束后，也排除了我的文章里的问题，还是没有成功，可以在这里或教程下留下评论，让大家一起找找。听说有官方QQ群，但是不知道是哪个😴</p>]]></content>
    
    
    <categories>
      
      <category>Github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>waline</tag>
      
      <tag>comments</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora基本使用教程</title>
    <link href="/2024/04/21/Typora%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2024/04/21/Typora%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本文旨在帮助刚刚入门Typora的大家写博文👻。</p><span id="more"></span><p>​打开Typora后，看到一片空白一定有些蒙圈。不要害怕！学会文中的几个指令后就能丝滑写出像样的文章啦，其实Typora和word相差也没有太大。</p><h4 id="一、如何写Frontmatter？"><a href="#一、如何写Frontmatter？" class="headerlink" title="一、如何写Frontmatter？"></a>一、如何写Frontmatter？</h4><h5 id="1-何为frontmatter？"><a href="#1-何为frontmatter？" class="headerlink" title="1.何为frontmatter？"></a>1.何为frontmatter？</h5><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240421141453727.png" alt="image-20240421141453727"></p><p>它定义了你的博文标题、这篇博文的分类、标签和作者名等。</p><p>对于我的博客来说，作者一般都是我自己，在主题配置文件修改过后就不用每次都写一遍了。除此之外，时间一般会默认为创建博文文档的时间，也可自行修改。</p><h5 id="2-写frontmatter的格式是什么？"><a href="#2-写frontmatter的格式是什么？" class="headerlink" title="2.写frontmatter的格式是什么？"></a>2.写frontmatter的格式是什么？</h5><p>若想在博文中插入frontmatter，需要打出三个短横线“—”，再Enter，可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240421142133810.png" alt="image-20240421142133810"></p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240421142500459.png" alt="image-20240421142500459"></p><p>注意：1.只有在博文最上方打frontmatter才会生效</p><p>​2.要使用英文冒号，冒号后需要有空格。</p><p>​3.若需要打多个标签，格式如下：<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240421142627174.png" alt="image-20240421142627174"></p><h5 id="3-常见的frontmatter"><a href="#3-常见的frontmatter" class="headerlink" title="3.常见的frontmatter"></a>3.常见的frontmatter</h5><p>title：标题</p><p>auther：作者</p><p>date：建立日期</p><p>updated：更新日期</p><p>comments：是否开启文章评论功能（默认值true）</p><p>tags：标签</p><p>categories：分类</p><p>permalink：覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</p><p>published：文章是否发布</p><h4 id="二、写文章常用指令"><a href="#二、写文章常用指令" class="headerlink" title="二、写文章常用指令"></a>二、写文章常用指令</h4><h5 id="1-多级标题"><a href="#1-多级标题" class="headerlink" title="1.多级标题"></a>1.多级标题</h5><p>在写文章时，往往需要用到多级标题。在Typora里，一级标题的字大小最大。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br></code></pre></td></tr></table></figure><p>依次类推。#后要加空格才会生效。</p><h5 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h5><p>如果想要在文中加入可直接复制的代码块，只需要打出”&#96;&#96;&#96;“再Enter。</p><p>代码块右下方可以调整代码语言。</p><h5 id="3-emjoy"><a href="#3-emjoy" class="headerlink" title="3.emjoy"></a>3.emjoy</h5><p>很多好看的emjoy都在这个网页：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">🎁 Emoji cheat sheet for GitHub, Basecamp, Slack &amp; more (webfx.com)</a></p><p>下滑找到喜欢的emjoy点击就能够复制了哦😋。</p><h5 id="4-加粗字体-斜体等"><a href="#4-加粗字体-斜体等" class="headerlink" title="4.加粗字体&#x2F;斜体等"></a>4.加粗字体&#x2F;斜体等</h5><p>只要鼠标圈出想要修改的文本，右键就可以修改啦。</p>]]></content>
    
    
    <categories>
      
      <category>Typora</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github图床配置教程</title>
    <link href="/2024/04/15/Typora%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <url>/2024/04/15/Typora%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本文详细地描述了如何利用Typora+PicGo+Github建立图床，并且列出了很多新手容易踩的坑（自己淋过雨要为大家撑伞）。如果对于某些步骤有疑惑或者出错了可以留下评论。</p><span id="more"></span><h3 id="一、建立Github仓库"><a href="#一、建立Github仓库" class="headerlink" title="一、建立Github仓库"></a>一、建立Github仓库</h3><h5 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1.新建仓库"></a>1.新建仓库</h5><p>先登录进自己的Github账号，按图示依次点击，就能新建一个仓库了。</p><p>（1）<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415201356717.png" alt="image-20240415201356717"></p><p>（2）</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415201449418.png" alt="image-20240415201449418"></p><p>（3）填写仓库名，设置为公开，记得要勾选添加README文件，这样才能在仓库中直接创建一个默认的main分支。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415202107013.png" alt="image-20240415202107013"></p><h5 id="2-生成一个token，用于PicGo访问Github"><a href="#2-生成一个token，用于PicGo访问Github" class="headerlink" title="2.生成一个token，用于PicGo访问Github"></a>2.生成一个token，用于PicGo访问Github</h5><p>（1）依次进入settings&#x2F;Developer settings&#x2F;Personal access tokens</p><p>（反正作者的Github上真的找不到这样一个路径，所以以上工作做好后，可以直接访问如下网站进入这个界面，亲测无误。网址：<a href="https://github.com/settings/tokens">Personal Access Tokens (Classic) (github.com)</a>）</p><p>（2）（据说选上面的Beta选项会变得不幸，虽然作者第一次失败时也是选了上面的Beta选项，但是由于还存在其他漏洞，所以它究竟可不可用不得而知）<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415203006752.png" alt="image-20240415203006752"></p><p>（3）Note随便写就行，时间限度我选了永久，因为害怕token失效；</p><p>下面的其他选项都不用管，只要将repo勾选上就好。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415203417667.png" alt="image-20240415203417667"></p><p>（4）得到token后好好保存（它只会在这里显示一次），等会还需要用上。</p><p>tips：如果因为某些步骤失误，需要重新生成token，记得把先前生成的token删掉。</p><h3 id="二、PicGo配置"><a href="#二、PicGo配置" class="headerlink" title="二、PicGo配置"></a>二、PicGo配置</h3><h5 id="1-下载PicGo"><a href="#1-下载PicGo" class="headerlink" title="1.下载PicGo"></a>1.下载PicGo</h5><p>（1）点击链接，直达：<a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.1">Release 2.3.1 · Molunerfinn&#x2F;PicGo (github.com)</a></p><p>（2）我所给出的链接是2.3.1正式版，如果需要最新版，可以点击releases，如图<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415204546713.png" alt="image-20240415204546713"></p><p>（3）在2.3.1这个版本界面一直下滑，直到如图，点击Assets会出现以下版本，可根据需求下载。比如我的设备是Windows11，我下载的版本已在图中圈出。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415204936447.png" alt="image-20240415204936447"></p><p>（4）下载后进行安装，步骤比较简单就省略了。记住安装时的路径，后面会需要。</p><p>（5）然后！是作者踩得一个大坑。在安装后，我怎么都无法打开这个软件。一开始我以为是版本不兼容等问题，但是设置之后仍旧无法打开。但是任务管理器上它明明就在运行……我还卸载重新安装了很多次。后来才发现，点开如图的地方，才发现它在偷偷运行呢！不知道为什么它运行时居然不显示界面，需要点一下才会显示。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415205718027.png" alt="image-20240415205718027"></p><h5 id="2-PicGo配置"><a href="#2-PicGo配置" class="headerlink" title="2.PicGo配置"></a>2.PicGo配置</h5><p>（1）进入PicGo后，将框住的地方修改为Github</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415205845506.png" alt="image-20240415205845506"></p><p>（2）点击图床设置，选择Github设置，进入如下界面。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415210205262.png" alt="image-20240415210205262"></p><p>仓库名格式：“Github用户名&#x2F;仓库名”</p><p>分支名：main（不要用master）</p><p>token：在第一步保存的token直接粘贴进来</p><p>存储路径：可设可不设</p><p>自定义域名格式：<a href="https://cdn.jsdelivr.net/gh/[Github%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]@main">https://cdn.jsdelivr.net/gh/[Github用户名]/[仓库名]@main</a></p><p>（这个域名据说可以加快访问图片的速度，不知道日后会不会失效，但是暂时是可以用的）</p><p>点击确定，PicGo就配置好啦。</p><p>（3）补充：点击PicGo设置中的设置sever，如果下图处不是36677要修改为36677，否则会出错</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415210909195.png" alt="image-20240415210909195"></p><h3 id="三、Typora配置"><a href="#三、Typora配置" class="headerlink" title="三、Typora配置"></a>三、Typora配置</h3><p>（1）点击右上角文件，进入偏好设置</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415211109267.png" alt="image-20240415211109267"></p><p>（2）进入图像设置，插入图片时选择上传图片，并将如图所示的选项打勾；</p><p>上传服务设定设置为PicGo（app），下面填写PicGo安装的路径，一定要填写完整，把PicGo.exe也要放到路径里。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415211453817.png" alt="image-20240415211453817"></p><p>（3）至此所有的配置已经完成。</p><p>确保网络已经连接好，点击上图左下角的验证图片上传选项，若出现如下图的界面，证明上传成功，PicGo应用也会发来通知说上传成功。此时在自己的Github仓库里也能够找到相应图片。</p><p><img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240415211851779.png" alt="image-20240415211851779"></p><p>如果仍然不成功也不要气馁呀。作者配置了快一天才成功…………因为先配置了Gitee结果发现它失效了（失效了还不删教程，太过分了！！！！）</p><p>如果配置成功啦就恭喜你啦，从此以后就可以丝滑地在Typora里粘贴图片了~</p>]]></content>
    
    
    <categories>
      
      <category>Typora</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>Github</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【踩雷合辑】利用Hexo搭建以fluid为主题的Github博客需要注意什么？</title>
    <link href="/2024/04/13/github%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E6%95%99%E7%A8%8B/"/>
    <url>/2024/04/13/github%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>​搭建博客是一个非常漫长的过程，在期间我参照过几十篇教程，在非常厉害的Gina同学的帮助下，反反复复试验了很多很多次，经过很多天后才终于能通过我的博客网址访问我的博客主页啦。<span id="more"></span>中间踩过不少雷，有时候一度绝望过（因为在网上根本搜不到和我一样的错误QAQ），好在最终坚持下来了。</p><p>​先附上fluid主题的官方文档：<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a>里面有很详细的配置教程哦。</p><h4 id="一、-config-yml配置文件撰写"><a href="#一、-config-yml配置文件撰写" class="headerlink" title="一、_config.yml配置文件撰写"></a>一、_config.yml配置文件撰写</h4><p>​它就在你所搭建的博客文档的根目录里，是非常重要的配置文档。</p><h5 id="1-博客主题修改"><a href="#1-博客主题修改" class="headerlink" title="1.博客主题修改"></a>1.博客主题修改</h5><p>​打开文档后拉到下面，找到<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20240416163624718.png" alt="image-20240416163624718"></p><p>​将theme后改为fluid，注意fluid主题的文件要放入themes文件夹里。如果是下载了zip压缩包，需要将其解压到该文件夹里并修改名字为fluid。</p><h5 id="2-deploy配置"><a href="#2-deploy配置" class="headerlink" title="2.deploy配置"></a>2.deploy配置</h5><p>​这个代码块就在主题配置的下方。注意不要按照网上搜索的教程配置，因为很多教程都已经很老了，所以可能会出问题。按照下面的格式配置是没有问题的。（分支必须是main）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># <span class="hljs-title class_">Deployment</span><br>## <span class="hljs-title class_">Docs</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy</span>:<br>  <span class="hljs-attr">type</span>: git<br>  <span class="hljs-attr">repo</span>: git@github.<span class="hljs-property">com</span>:[博客名]/[仓库名].<span class="hljs-property">github</span>.<span class="hljs-property">io</span>.<span class="hljs-property">git</span><br>  <span class="hljs-attr">branch</span>: main<br></code></pre></td></tr></table></figure><p>注意：每个冒号后都有一个空格。</p><h5 id="3-记得保存修改"><a href="#3-记得保存修改" class="headerlink" title="3.记得保存修改"></a>3.记得保存修改</h5><p>​我所用的编译软件是vscode，这个软件直接退出是不会保存的。快捷键Ctrl+s可以保存修改，然后不用退出就可以继续hexo g+hexo s两步走试看网页效果啦。</p><h4 id="二、博客部署的问题"><a href="#二、博客部署的问题" class="headerlink" title="二、博客部署的问题"></a>二、博客部署的问题</h4><p>​我们知道要搭建博客，就要去Github官网创建一个博客，然后再建立一个仓库用于保存我们的网页。博客的名字可以随意取，但是仓库名，如果你和我一样取的是英文名，<strong>第一个字母一定要小写！！！！！</strong></p><p>​因为我们会发现，当我们想要进入自己的博客官网时，输入的网址格式如下：https:&#x2F;&#x2F;[仓库名].github.io&#x2F;，而每次进入网址时，仓库名的第一个字母就会自动从大写变成小写，因此访问时就会显示404。</p><p>​不知道是主题的问题还是什么，反正这个问题害我找bug找了快两个小时……</p><h5 id="1-配置安装缺失"><a href="#1-配置安装缺失" class="headerlink" title="1.配置安装缺失"></a>1.配置安装缺失</h5><p>有时候hexo d后报错是因为有些配置没有安装,用下面的指令安装好就可</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h5 id="2-在根目录下部署"><a href="#2-在根目录下部署" class="headerlink" title="2.在根目录下部署"></a>2.在根目录下部署</h5><p>有时候搭建博客在部署时会忘记退出到根目录，此时也会出错。</p><h4 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h4><p>1.在部署博客时最好hexo clean后再hexo g+hexo d。</p><p>2.博文的文件放置在source文件夹下的_posts文件夹内。（fluid主题配置后都会默认创建一个这样的文件，里面有一篇默认的文档）</p><p>3.博客主题文档的配置需要很多图片，千万不要把他们放在public文件夹下。因为public是每次部署博客生成的静态文件，每次hexo clean之后就会将其删除。但是博客文件是会保留下来的，所以不用担心。那么<strong>这些照片，最好放在source文件夹下的img文件夹内保存</strong>（若没有就新建一个这样的文件夹）。</p>]]></content>
    
    
    <categories>
      
      <category>Github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/12/hello-world/"/>
    <url>/2024/04/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
