

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/IMG_20240421_150811.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yaodeer">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下在笔试或面试中的八股知识。融合一下其他人总结的。">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股总结-JS（持续更新）">
<meta property="og:url" content="http://example.com/2024/10/23/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%93-JS/index.html">
<meta property="og:site_name" content="Yaodeer">
<meta property="og:description" content="记录一下在笔试或面试中的八股知识。融合一下其他人总结的。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20241029125906648.png">
<meta property="article:published_time" content="2024-10-23T12:23:08.194Z">
<meta property="article:modified_time" content="2024-11-04T05:38:37.859Z">
<meta property="article:author" content="Yaodeer">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20241029125906648.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>前端八股总结-JS（持续更新） - Yaodeer</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 85vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>姚姚</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/MVIMG_20231023_100821.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端八股总结-JS（持续更新）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-10-23 20:23" pubdate>
          October 23, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          91 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">前端八股总结-JS（持续更新）</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    Last updated on November 4, 2024 pm
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>记录一下在笔试或面试中的八股知识。融合一下其他人总结的。</p>
<span id="more"></span>

<p><strong>是谁还不知道在vscode安装Code Running拓展就可以无痛跑js、c++等代码🥹</strong></p>
<h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><h4 id="0、ES6新特性"><a href="#0、ES6新特性" class="headerlink" title="0、ES6新特性"></a>0、ES6新特性</h4><h5 id="⭕块级作用域"><a href="#⭕块级作用域" class="headerlink" title="⭕块级作用域"></a>⭕块级作用域</h5><ul>
<li><code>let</code>：用于声明块级作用域的变量。</li>
<li><code>const</code>：用于声明常量，一旦赋值后不能更改。</li>
</ul>
<h5 id="⭕箭头函数"><a href="#⭕箭头函数" class="headerlink" title="⭕箭头函数"></a>⭕箭头函数</h5><h5 id="⭕模板字符串"><a href="#⭕模板字符串" class="headerlink" title="⭕模板字符串"></a>⭕模板字符串</h5><h5 id="⭕解构赋值"><a href="#⭕解构赋值" class="headerlink" title="⭕解构赋值"></a>⭕解构赋值</h5><p>解构赋值允许从数组或对象中提取值，并赋值给变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> [a, b] = arr;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// 输出: 1 2</span><br><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> &#123; x, y &#125; = obj;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y); <span class="hljs-comment">// 输出: 1 2</span><br></code></pre></td></tr></table></figure>

<h5 id="⭕默认参数"><a href="#⭕默认参数" class="headerlink" title="⭕默认参数"></a>⭕默认参数</h5><p>如果没有值或者传入了未定义的值，默认参数允许形式参数使用默认值初始化</p>
<h5 id="⭕剩余参数和扩展运算符"><a href="#⭕剩余参数和扩展运算符" class="headerlink" title="⭕剩余参数和扩展运算符"></a>⭕剩余参数和扩展运算符</h5><p>剩余参数可以将不确定数量的参数组合为数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers</span>) &#123;<br>    <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出: 10</span><br></code></pre></td></tr></table></figure>

<p>拓展运算符可以展开数组或对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> newNums = [...nums, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newNums); <span class="hljs-comment">// 输出: [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>

<h5 id="⭕Promise"><a href="#⭕Promise" class="headerlink" title="⭕Promise"></a>⭕Promise</h5><p>处理异步操作的新方法，允许更清晰地处理成功和失败的结果。</p>
<h5 id="⭕类（Class）"><a href="#⭕类（Class）" class="headerlink" title="⭕类（Class）"></a>⭕类（Class）</h5><p>引入类的概念，使得创建对象的方式更加清晰。</p>
<h5 id="⭕模块（Module）"><a href="#⭕模块（Module）" class="headerlink" title="⭕模块（Module）"></a>⭕模块（Module）</h5><p>ES6 提供了模块化的支持，可以使用 <code>export</code> 和 <code>import</code> 语句导出和导入模块。</p>
<h4 id="0、JS语言特性"><a href="#0、JS语言特性" class="headerlink" title="0、JS语言特性"></a>0、JS语言特性</h4><h5 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h5><p>JS是一种弱类型的语言，变量可以在运行时动态改变类型。</p>
<h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><p>JS采用原型链的方式实现继承。</p>
<p>对象可以通过原型（<code>__proto__</code>）链接到其他对象，从而共享属性和方法</p>
<h5 id="一等函数"><a href="#一等函数" class="headerlink" title="一等函数"></a>一等函数</h5><p>函数在JS中是“一等公民”，可以被赋值给变量、作为参数传递和作为返回值</p>
<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>JS中可以实现闭包，指函数可以记住其外部作用域的变量，即使在外部函数已经返回后</p>
<h5 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h5><p>JS支持异步编程，通过回调函数、Promise和async&#x2F;await处理异步操作</p>
<h5 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h5><p>JS是事件驱动的，特别是在浏览器环境中，用户交互（如点击、键盘输入等）会触发事件处理程序。</p>
<h4 id="1、console-info"><a href="#1、console-info" class="headerlink" title="1、console.info()"></a>1、<code>console.info()</code></h4><p><code>console.info()</code> 是 JavaScript 中 <code>console</code> 对象的一个方法，用于在浏览器的开发者工具控制台中输出信息。它的功能类似于 <code>console.log()</code>，但通常用于记录信息级别的日志。</p>
<h4 id="2、帮你彻底搞懂JS中的prototype、-proto-与constructor（图解）-js-prototype-constructor-CSDN博客"><a href="#2、帮你彻底搞懂JS中的prototype、-proto-与constructor（图解）-js-prototype-constructor-CSDN博客" class="headerlink" title="2、帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）_js prototype constructor-CSDN博客"></a>2、<a target="_blank" rel="noopener" href="https://blog.csdn.net/cc18868876837/article/details/81211729?ops_request_misc=%7B%22request_id%22:%224D358ECD-189D-47AA-BE6C-CED4356284C6%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=4D358ECD-189D-47AA-BE6C-CED4356284C6&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81211729-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=prototype&spm=1018.2226.3001.4187">帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）_js prototype constructor-CSDN博客</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断 p 是否为 Person 的实例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;sunshine&#x27;</span>)<br>p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 这里的 p 是 Person 函数构造出来的，所以顺着 p 的原型链可以找到 Object 的构造函数</span><br>p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h5 id="proto"><a href="#proto" class="headerlink" title="_ _ proto _ _"></a>_ _ proto _ _</h5><p>是每个对象的内部属性，它指向对象的原型。（任何通过构造函数创建的对象都会有一个__ proto __属性，指向其构造函数的prototype属性）</p>
<p>当访问对象属性的时候，如果对象没有这个属性，js会查找其__ proto __指向的对象，依次类推，直到找到该属性或达到原型链的顶端（即Object.prototype）</p>
<p>现在js中，建议使用Object.getPrototypeOf(obj)来获取对象的原型</p>
<h5 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h5><p>是函数对象的属性，用于定义实例化对象的原型。</p>
<p>当你向构造函数的prototype添加属性或者方法时，所有通过该构造函数创建的实例都可以访问这些属性或者方法。</p>
<h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>是每个对象的属性，指向创建该对象的构造函数。当通过构造函数创建一个对象时，该对象的constructor指向该构造函数。</p>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>原型链解决的是继承的问题。</p>
<p>每个对象都有一个原型，通过dunder proto指向其原型对象，从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向null。这种关系被称为原型链，通过原型链，一个对象可以拥有定义在其他对象中的属性和方法。</p>
<h4 id="3、Object-assign详解-CSDN博客"><a href="#3、Object-assign详解-CSDN博客" class="headerlink" title="3、Object.assign详解-CSDN博客"></a>3、<a target="_blank" rel="noopener" href="https://blog.csdn.net/guxin_duyin/article/details/88916106?ops_request_misc=%7B%22request_id%22:%2251FF465A-6E67-41F2-8FBC-8D29316BCA96%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=51FF465A-6E67-41F2-8FBC-8D29316BCA96&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88916106-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=object.assign&spm=1018.2226.3001.4187">Object.assign详解-CSDN博客</a></h4><p> <strong><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</strong></p>
<h4 id="4、看这一篇就够了！-Ajax详解-ajax解析-CSDN博客"><a href="#4、看这一篇就够了！-Ajax详解-ajax解析-CSDN博客" class="headerlink" title="4、看这一篇就够了！-Ajax详解_ajax解析-CSDN博客"></a>4、<a target="_blank" rel="noopener" href="https://blog.csdn.net/Oriental_/article/details/104863762?ops_request_misc=%7B%22request_id%22:%22B4AF4373-CC0B-4840-A14D-AA79FED7133B%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=B4AF4373-CC0B-4840-A14D-AA79FED7133B&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104863762-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=ajax&spm=1018.2226.3001.4187">看这一篇就够了！-Ajax详解_ajax解析-CSDN博客</a></h4><h4 id="5、数据类型"><a href="#5、数据类型" class="headerlink" title="5、数据类型"></a>5、数据类型</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45811256/article/details/127572573?ops_request_misc=%7B%22request_id%22:%22B81D8FB6-F82B-4874-AF5C-8493977CAD29%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=B81D8FB6-F82B-4874-AF5C-8493977CAD29&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-13-127572573-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95&spm=1018.2226.3001.4187">js中判断数据类型的几种实用方法_js判断类型-CSDN博客</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>([]); <span class="hljs-comment">//true</span><br><span class="hljs-title class_">Number</span>([]); <span class="hljs-comment">//0</span><br><span class="hljs-title class_">Number</span>(&#123;&#125;); <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>



<p><strong>typeof NaN&#x3D;Number</strong></p>
<p><strong>NaN!&#x3D;&#x3D;NaN</strong> （Not a Number）</p>
<p>做减法运算时，有一个是NaN结果就是NaN。</p>
<p>isNaN()会先将参数转为Number 类型，再判断是否为NaN。</p>
<ul>
<li><code>console.log(isNaN(&#39;&#39;));//false</code></li>
</ul>
<h4 id="5-1、原始类型和引用类型在函数中的行为"><a href="#5-1、原始类型和引用类型在函数中的行为" class="headerlink" title="5.1、原始类型和引用类型在函数中的行为"></a>5.1、原始类型和引用类型在函数中的行为</h4><p>（没见到有人总结，那我自己浅总结一下吧）</p>
<p>原始数据类型由于传入的是值的拷贝，所以不会影响外部变量，不详细说了</p>
<p>由于引用数据类型在函数中是按照引用传递的，所以在函数中直接修改是可能会影响到外部的值的，所以下面来具体情况具体分析一下。</p>
<h5 id="😕直接修改内部属性的值"><a href="#😕直接修改内部属性的值" class="headerlink" title="😕直接修改内部属性的值"></a>😕直接修改内部属性的值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">modifyReference</span>(<span class="hljs-params">array, object</span>) &#123;<br>    array.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br>    object.<span class="hljs-property">key</span> = <span class="hljs-string">&quot;new value&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_">modifyReference</span>(arr, obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr, obj); <span class="hljs-comment">// 输出: [1, 2, 3, 4] &#123; key: &quot;new value&quot; &#125;</span><br></code></pre></td></tr></table></figure>

<p>可以看出这样是可以修改外部变量的。</p>
<h5 id="🙂重新赋值"><a href="#🙂重新赋值" class="headerlink" title="🙂重新赋值"></a>🙂重新赋值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reassignReference</span>(<span class="hljs-params">array, object</span>) &#123;<br>    array = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]; <span class="hljs-comment">// 重新赋值为新数组</span><br>    object = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;new value&quot;</span> &#125;; <span class="hljs-comment">// 重新赋值为新对象</span><br>&#125;<br><br><span class="hljs-title function_">reassignReference</span>(arr, obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr, obj); <span class="hljs-comment">// 输出: [1, 2, 3] &#123; key: &quot;value&quot; &#125;</span><br></code></pre></td></tr></table></figure>

<p>重新赋值后产生的新变量只在函数作用域中有效，不会影响到外部的arr和obj</p>
<h5 id="🙂Object-freeze"><a href="#🙂Object-freeze" class="headerlink" title="🙂Object.freeze"></a>🙂Object.freeze</h5><p>可以冻结对象或数组，使其属性不可更改，但是其子属性仍旧可以更改。也就是说，如果一个对象里包含另一个对象，还是可以修改那个对象的值的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(obj)<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;李四&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)    <span class="hljs-comment">// &#123;info: &#123;a: 1, b: 2&#125;,name: &quot;张三&quot;&#125;</span><br>obj.<span class="hljs-property">info</span>.<span class="hljs-property">a</span> = <span class="hljs-number">66</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">info</span>)   <span class="hljs-comment">// &#123;a: 66, b: 2&#125;</span><br></code></pre></td></tr></table></figure>



<h5 id="🙂深拷贝"><a href="#🙂深拷贝" class="headerlink" title="🙂深拷贝"></a>🙂深拷贝</h5><p>深拷贝的对象被修改不会影响原对象，而浅拷贝会。</p>
<h4 id="5-2、数组类型详解"><a href="#5-2、数组类型详解" class="headerlink" title="5.2、数组类型详解"></a>5.2、数组类型详解</h4><ul>
<li>JavaScript 数组是<strong>可调整大小</strong>的，并且可以**包含不同的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">数据类型</a>**。（当不需要这些特征时，可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Typed_arrays">类型化数组</a>。）</li>
<li>JavaScript 数组不是关联数组，因此，<strong>不能使用任意字符串作为索引</strong>访问数组元素，但必须使用非负整数（或它们各自的字符串形式）作为索引访问。</li>
<li>JavaScript 数组的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E7%9A%84%E7%B7%A8%E8%99%9F">索引从 0 开始</a>：数组的第一个元素在索引 <code>0</code> 处，第二个在索引 <code>1</code> 处，以此类推，最后一个元素是数组的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性减去 <code>1</code> 的值。</li>
<li>JavaScript <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84">数组复制操作</a>创建<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Shallow_copy">浅拷贝</a>。（<em>所有</em> JavaScript 对象的标准内置复制操作都会创建浅拷贝，而不是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Deep_copy">深拷贝</a>）。</li>
</ul>
<h5 id="定义和创建"><a href="#定义和创建" class="headerlink" title="定义和创建"></a>定义和创建</h5><ul>
<li><p>数组字面量方法：<code>const fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;];</code></p>
</li>
<li><p>Array构造函数：</p>
<ul>
<li><p><code>new Array(1, 2, 3)</code>（ [ 1 , 2 , 3 ] ）</p>
</li>
<li><p><code>new Array(5)</code>（长度为5的空数组）</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>String.prototype.split()</code></a>：<code>const fruits3 = &quot;Apple, Banana&quot;.split(&quot;, &quot;);</code></p>
</li>
</ul>
<h4 id="5-2、String类型"><a href="#5-2、String类型" class="headerlink" title="5.2、String类型"></a>5.2、String类型</h4><h4 id="6、JSON-stringfy和JSON-parse"><a href="#6、JSON-stringfy和JSON-parse" class="headerlink" title="6、JSON.stringfy和JSON.parse"></a>6、JSON.stringfy和JSON.parse</h4><p>🐼<code>JSON.stringfy</code></p>
<blockquote>
<p>JSON.stringify(value[, replacer[, space]])</p>
</blockquote>
<ul>
<li>用途：将 JavaScript 对象转换为 JSON 字符串，方便存储和传输。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">job</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">hobbies</span>: [<span class="hljs-string">&quot;reading&quot;</span>, <span class="hljs-string">&quot;traveling&quot;</span>] &#125;;<br><span class="hljs-keyword">const</span> jsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonString); <br><span class="hljs-comment">// 输出: &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:null,&quot;hobbies&quot;:[&quot;reading&quot;,&quot;traveling&quot;]&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>特殊行为</p>
<ul>
<li><p><code>undefined</code>：在对象中，值为 <code>undefined</code> 的属性会被忽略。</p>
</li>
<li><p>函数：如果对象包含函数，函数会被忽略。</p>
</li>
<li><p><code>symbol</code>：如果对象包含 <code>symbol</code> 类型的属性，属性会被忽略。</p>
</li>
<li><p><code>null</code>：会被保留，转换为 JSON 字符串中的 <code>null</code>。</p>
</li>
<li><p>数组：会被正常序列化。</p>
</li>
</ul>
</li>
</ul>
<p>🐻‍❄️<code>JSON.parse</code></p>
<blockquote>
<p>JSON.parse(text[, reviver])</p>
</blockquote>
<ul>
<li><p>用途：将 JSON 字符串解析为 JavaScript 对象，方便在程序中使用。</p>
</li>
<li><p>特殊行为：</p>
<ul>
<li><p><code>null</code>：解析字符串 <code>&quot;null&quot;</code> 会返回 <code>null</code>。</p>
</li>
<li><p>不支持 <code>undefined</code>：如果 JSON 字符串包含 <code>undefined</code>，解析会失败。</p>
</li>
<li><p>错误处理：如果传入的字符串不是有效的 JSON，<code>JSON.parse</code> 会抛出错误。</p>
</li>
</ul>
</li>
</ul>
<h4 id="7、V8垃圾回收"><a href="#7、V8垃圾回收" class="headerlink" title="7、V8垃圾回收"></a>7、V8垃圾回收</h4><blockquote>
<p>V8 是 Google 开发的高性能 JavaScript 引擎，广泛应用于 Chrome 浏览器和 Node.js。V8 的垃圾回收机制（Garbage Collection, GC）旨在自动管理内存，以确保不再使用的对象能够被清除，从而释放内存空间。</p>
</blockquote>
<h5 id="🕊️基本概念"><a href="#🕊️基本概念" class="headerlink" title="🕊️基本概念"></a>🕊️基本概念</h5><ul>
<li>垃圾回收：指的是自动释放不再使用的内存空间，防止内存泄漏和提高内存使用效率。</li>
<li>根对象：包括全局对象、活动函数的局部变量等，垃圾回收的起点。</li>
</ul>
<h5 id="🕊️回收机制"><a href="#🕊️回收机制" class="headerlink" title="🕊️回收机制"></a>🕊️回收机制</h5><ul>
<li><p>标记-清除</p>
<ul>
<li><p>标记阶段：从根对象开始遍历所有可达对象，并标记它们为“存活”</p>
</li>
<li><p>清除阶段：扫描堆内存，将未被标记的对象（不可达对象）清除，释放内存</p>
</li>
</ul>
</li>
<li><p>分代收集</p>
<ul>
<li>V8 将内存分为两个主要区域：<strong>新生代</strong>（Young Generation）和<strong>老生代</strong>（Old Generation）。</li>
<li>新生代中的对象是短暂的，频繁进行垃圾回收；老生代中的对象则相对长寿，收集频率较低。</li>
</ul>
</li>
<li><p>新生代垃圾回收</p>
<ul>
<li><strong>Scavenge 算法</strong>：使用复制算法，在新生代中，活着的对象会从一个内存区域复制到另一个区域，释放原来的区域内存。可以快速清理不再使用的对象。</li>
</ul>
</li>
<li><p>老生代垃圾回收</p>
<ul>
<li><strong>Mark-Sweep 和 Mark-Compact</strong>：在老生代中，V8 会使用标记-清除和标记-压缩算法。标记-压缩会整理存活对象，以消除内存碎片。</li>
</ul>
</li>
</ul>
<h5 id="🕊️垃圾回收的触发"><a href="#🕊️垃圾回收的触发" class="headerlink" title="🕊️垃圾回收的触发"></a>🕊️垃圾回收的触发</h5><ul>
<li>内存压力：当内存使用达到一定阈值时，触发垃圾回收。</li>
<li>手动触发：在 Node.js 中可以通过 <code>global.gc()</code> 手动触发垃圾回收（需启动时加上 <code>--expose-gc</code> 标志）。</li>
</ul>
<h5 id="🕊️优化"><a href="#🕊️优化" class="headerlink" title="🕊️优化"></a>🕊️优化</h5><blockquote>
<p>减少停顿时间和内存使用</p>
</blockquote>
<ul>
<li>增量回收：将回收过程分成多个小步骤，减少长时间的停顿。</li>
<li>并行回收：在多线程环境中，部分垃圾回收过程可以并行进行，以提高效率。</li>
</ul>
<h4 id="8、防抖和节流"><a href="#8、防抖和节流" class="headerlink" title="8、防抖和节流"></a>8、防抖和节流</h4><blockquote>
<p><strong>防抖（Debounce）</strong>和<strong>节流（Throttle）</strong>是两种常用的性能优化技术，主要用于控制函数执行的频率，尤其是在处理高频事件（如滚动、输入、窗口大小变化等）时。</p>
</blockquote>
<h5 id="🐻‍❄️防抖："><a href="#🐻‍❄️防抖：" class="headerlink" title="🐻‍❄️防抖："></a>🐻‍❄️防抖：</h5><p>防抖是一种延迟执行的技术，用于确保事件处理函数在一段时间内不会被频繁调用，只有在事件停止触发后，防抖函数才会执行一次。（如用户输入时只有停止输入后再进行搜索）</p>
<p>工作原理：</p>
<ul>
<li>当事件被触发时，防抖函数会启动一个计数器。</li>
<li>如果在计数器到期之前事件被再次触发，计数器将被重置。</li>
<li>只有在事件停止触发超过设定时间后，事件处理函数才会被调用。</li>
</ul>
<p>应用场景：</p>
<ul>
<li>输入框的变化；</li>
<li>窗口调整大小；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>) &#123;<br>   <span class="hljs-keyword">let</span> timer;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)&#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>         fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args);<br>      &#125;,delay);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="🐨节流："><a href="#🐨节流：" class="headerlink" title="🐨节流："></a>🐨节流：</h5><p>节流是一种控制函数执行频率的技术，用于确保事件处理函数在一定时间间隔内只被调用一次。（如用户滚动界面时控制频率，API请求时限制请求频率）。</p>
<p>工作原理：</p>
<ul>
<li>节流函数在时间触发时会立即执行，并且在设定的时间间隔内，不管事件触发多少次都不会再执行。在时间间隔结束后，下一次事件触发时函数会再次执行。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,interval</span>)&#123;<br>   <span class="hljs-keyword">let</span> lastTime=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>      <span class="hljs-keyword">const</span> now=<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">if</span>(now-lastTime&gt;=interval)&#123;<br>         lastTime=now;<br>         fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="9、call、apply、bind"><a href="#9、call、apply、bind" class="headerlink" title="9、call、apply、bind"></a>9、call、apply、bind</h4><h5 id="🦔this"><a href="#🦔this" class="headerlink" title="🦔this"></a>🦔this</h5><p><code>this</code> 指的是当前执行上下文的对象。它的值取决于<strong>函数是如何调用的</strong>。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>    <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//this指向person对象</span><br>person.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, Alice&quot;</span><br><span class="hljs-comment">//this指向默认的全局对象。在浏览器中是window对象，在Node.js中是global对象</span><br><span class="hljs-keyword">const</span> greetFn=person.<span class="hljs-property">greet</span>;<br><span class="hljs-title function_">greetFn</span>();   <span class="hljs-comment">//输出 &quot;Hello, undefined&quot; 或 &quot;Hello, [global object]&quot;</span><br></code></pre></td></tr></table></figure>

<h5 id="🦔call、apply、bind的作用"><a href="#🦔call、apply、bind的作用" class="headerlink" title="🦔call、apply、bind的作用"></a>🦔call、apply、bind的作用</h5><p>它们的作用是显式地设置函数执行时的<code>this</code>值。简单来说：</p>
<ul>
<li>call：立即调用函数，参数一个个传递</li>
<li>apply：立即调用函数，参数以数组的形式传递</li>
<li>bind：不立即调用函数，而是返回一个可以稍后再调用的新函数，可以固定<code>this</code>和部分参数</li>
</ul>
<h5 id="🦔call"><a href="#🦔call" class="headerlink" title="🦔call"></a>🦔call</h5><p>允许调用一个函数并明确指定函数内部this的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fn.<span class="hljs-title function_">call</span>(thisArg, arg1, arg2, ...);<br></code></pre></td></tr></table></figure>

<ul>
<li><code>thisArg</code>：指定 <code>this</code> 的值。</li>
<li><code>arg1, arg2, ...</code>：传给函数的参数，一个一个传递。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person1 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>    <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">greeting</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;;<br><br><span class="hljs-comment">// 使用 call 方法来调用 greet 并改变 this 指向</span><br>person1.<span class="hljs-property">greet</span>.<span class="hljs-title function_">call</span>(person2, <span class="hljs-string">&#x27;Hi&#x27;</span>); <span class="hljs-comment">// 输出 &quot;Hi, Bob&quot;</span><br></code></pre></td></tr></table></figure>

<h5 id="🦔apply"><a href="#🦔apply" class="headerlink" title="🦔apply"></a>🦔apply</h5><p>和call的唯一区别是传递参数的方式不同，apply<strong>使用数组</strong>来传递参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fn.<span class="hljs-title function_">apply</span>(thisArg, [argsArray]);<br></code></pre></td></tr></table></figure>

<h5 id="🦔bind"><a href="#🦔bind" class="headerlink" title="🦔bind"></a>🦔bind</h5><p>bind不会立即调用函数，而是<strong>返回一个新的函数</strong>，并且这个新的函数中的 <code>this</code> 已经被固定了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newFn=fn.<span class="hljs-title function_">bind</span>(thisArg,arg1,arg2,...)<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 bind 方法</span><br><span class="hljs-keyword">const</span> greetBob = person1.<span class="hljs-property">greet</span>.<span class="hljs-title function_">bind</span>(person2, <span class="hljs-string">&#x27;Hi&#x27;</span>);<br><br><span class="hljs-comment">// greetBob 现在是一个新的函数，并且 this 始终指向 person2</span><br><span class="hljs-title function_">greetBob</span>(); <span class="hljs-comment">// 输出 &quot;Hi, Bob&quot;</span><br><br><span class="hljs-built_in">setTimeout</span>(greetBob, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 一秒后输出 &quot;Hi, Bob&quot;</span><br></code></pre></td></tr></table></figure>

<p>即使在异步调用中，this也指向person2。</p>
<h4 id="10、闭包"><a href="#10、闭包" class="headerlink" title="10、闭包"></a>10、闭包</h4><p>简单来说，闭包就是<strong>一个函数以及他对外部变量的引用</strong>，这个函数能够”<strong>记住</strong>“它创建时的环境（作用域）。即使这个函数执行完成，或者它被传递到其他地方执行，他仍然可以访问在定义时的作用域中的变量。</p>
<h5 id="🕸️特性："><a href="#🕸️特性：" class="headerlink" title="🕸️特性："></a>🕸️特性：</h5><ul>
<li>函数嵌套函数</li>
<li>函数内部可以引用函数外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
<h5 id="🕸️优点"><a href="#🕸️优点" class="headerlink" title="🕸️优点"></a>🕸️优点</h5><ul>
<li>保护函数内的变量安全，实现封装，防止变量流入其他环境发生命名冲突。</li>
<li>在回调函数和事件处理函数中非常常用，它可以保留对当前作用域的访问</li>
<li>可以访问和保留外部函数作用域中的变量</li>
<li>可以帮助解决异步回调中变量值的保存问题</li>
<li>在早期 JavaScript 版本（ES6 之前）中没有 <code>let</code> 和 <code>const</code> 来创建块级作用域，但闭包可以用来模拟这种行为。</li>
</ul>
<h5 id="🕸️缺点"><a href="#🕸️缺点" class="headerlink" title="🕸️缺点"></a>🕸️缺点</h5><ul>
<li>如果不小心滥用闭包，可能会导致内存泄漏，因为闭包会持有对外部变量的引用，使这些变量不会被垃圾回收。</li>
<li>对于闭包的滥用，代码的可读性可能会下降，维护起来更复杂。</li>
</ul>
<h4 id="11、setTimeout-和-setInterval"><a href="#11、setTimeout-和-setInterval" class="headerlink" title="11、setTimeout 和 setInterval"></a>11、setTimeout 和 setInterval</h4><h5 id="🍁setTimeout"><a href="#🍁setTimeout" class="headerlink" title="🍁setTimeout"></a>🍁setTimeout</h5><p>在一定时间之后执行<strong>一次</strong>代码，接收两个参数：回调函数和delay（等待时间）</p>
<ul>
<li>取消：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This will not be shown&quot;</span>);<br>&#125;, <span class="hljs-number">3000</span>);<br><br><span class="hljs-built_in">clearTimeout</span>(timeoutId); <span class="hljs-comment">// 在计时结束前取消</span><br></code></pre></td></tr></table></figure>

<h5 id="🍁setInterval"><a href="#🍁setInterval" class="headerlink" title="🍁setInterval"></a>🍁setInterval</h5><p>每隔一段时间<strong>重复</strong>执行代码。</p>
<ul>
<li>取消：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This will be shown repeatedly every 2 seconds&quot;</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">clearInterval</span>(intervalId); <span class="hljs-comment">// 在 6 秒后取消 `setInterval`</span><br>&#125;, <span class="hljs-number">6000</span>);<br></code></pre></td></tr></table></figure>

<h5 id="🍁注意"><a href="#🍁注意" class="headerlink" title="🍁注意"></a>🍁注意</h5><ul>
<li><strong>精度问题</strong>：<code>setTimeout</code> 和 <code>setInterval</code> 的精度不高。尽管你设定了一个 1000 毫秒的延迟，实际执行时间可能会有一些误差，尤其在 JavaScript 的事件循环中，如果前面的任务阻塞了主线程，定时器的执行会被延后。</li>
<li><strong>setInterval 的问题</strong>：如果某次定时任务的执行时间超过了间隔时间，可能会导致下一个任务的执行时间被推迟，从而出现定时不准的情况。因此在有些情况下（例如要控制任务的精度），递归使用 <code>setTimeout</code> 是更好的选择。</li>
<li><strong>递归 setTimeout 优于 setInterval</strong>：若需要在每次定时任务完成之后再进行下一次任务时，使用递归 <code>setTimeout</code> 更好，因为它可以确保上一次任务完成后再开始下一次。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeatTask</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Task executed&quot;</span>);<br>      <span class="hljs-title function_">repeatTask</span>(); <span class="hljs-comment">//再次调用</span><br>   &#125;，<span class="hljs-number">1000</span>)；<br>&#125;<br><span class="hljs-title function_">repeatTask</span>()<br></code></pre></td></tr></table></figure>



<h4 id="12、Promise"><a href="#12、Promise" class="headerlink" title="12、Promise"></a>12、Promise</h4><blockquote>
<p><code>Promise</code> 是 JavaScript 中处理<strong>异步操作</strong>的一种方式。它提供了一种更清晰、结构化的方式来处理异步任务的结果，避免了回调地狱问题，并且让代码更易读易维护。</p>
</blockquote>
<h5 id="☀️什么是Promise"><a href="#☀️什么是Promise" class="headerlink" title="☀️什么是Promise"></a>☀️什么是Promise</h5><p>Promise是一个代表异步操作的对象。有三种状态：</p>
<ul>
<li>Pending（待定）：初始状态，操作未完成</li>
<li>Fulfilled（已兑现）：操作成功完成，并返回了一个值</li>
<li>Rejected（已拒绝）：操作失败，返回了一个拒绝（错误）原因</li>
</ul>
<p> Promise <strong>不可变</strong>：Promise 的状态一旦从 Pending 转为 Fulfilled 或 Rejected 就不会再改变</p>
<h5 id="🌤️基本用法"><a href="#🌤️基本用法" class="headerlink" title="🌤️基本用法"></a>🌤️基本用法</h5><p>通过Promise构造函数来创建一个Promise实例。构造函数接受一个执行器函数（executor），该函数有两个参数：</p>
<ul>
<li>resolve：当异步操作成功时调用，将 Promise 状态改为 Fulfilled。</li>
<li>reject：当异步操作失败时调用，将 Promise 状态改为 Rejected。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>   <span class="hljs-keyword">let</span> success=<span class="hljs-literal">true</span>;<br>   <br>   <span class="hljs-keyword">if</span>(success)&#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Task succeeded&quot;</span>);<br>   &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Task failed&quot;</span>);<br>   &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>



<h5 id="🌥️方法"><a href="#🌥️方法" class="headerlink" title="🌥️方法"></a>🌥️方法</h5><ul>
<li>.then：用于指定成功时的回调函数。</li>
<li>.catch：用于指定失败时的回调函数</li>
<li>finally：无论成功失败都执行；主要用于执行一些清理操作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">promise<br>   .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Success&quot;</span>: value);<br>   &#125;)<span class="hljs-comment">//可以添加处理失败的情况，但是不常用</span><br>	.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>   	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Error&quot;</span>: error);<br>	&#125;)<br>	.<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>   	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Operation complete&quot;</span>)<br>	&#125;)<br></code></pre></td></tr></table></figure>



<h5 id="☁️链式调用"><a href="#☁️链式调用" class="headerlink" title="☁️链式调用"></a>☁️链式调用</h5><blockquote>
<p>自动封装：如果在.then()中返回一个普通值，它会被自动封装成一个新的Promise</p>
</blockquote>
<p>当一个then返回一个新的promise的时候，可以继续在后面调用then进行处理。后续的.then()会等待这个promise解决后再执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 输出 1</span><br>    <span class="hljs-keyword">return</span> value + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回 2</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue); <span class="hljs-comment">// 输出 2</span><br>    <span class="hljs-keyword">return</span> newValue + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回 3</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">finalValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(finalValue); <span class="hljs-comment">// 输出 3</span><br>  &#125;);<br></code></pre></td></tr></table></figure>



<h5 id="🌧️常用静态方法"><a href="#🌧️常用静态方法" class="headerlink" title="🌧️常用静态方法"></a>🌧️常用静态方法</h5><ul>
<li>Promise.all()</li>
</ul>
<p>接收一个包含多个Promise的数组（或可迭代对象），并返回一个新的Promise。当所有Promise都成功时返回的状态才会是Fulfilled，并且所有Promise的结果会以数组形式返回。如果有一个Promise失败，返回的状态就会立即变成Rejected，并返回失败的原因。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1=<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> promise2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span><span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">1000</span>,<span class="hljs-number">2</span>));<br><span class="hljs-keyword">const</span> promise3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span><span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">2000</span>,<span class="hljs-number">3</span>));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>)=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values); <span class="hljs-comment">//[1,2,3]</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>Promise.any()</li>
</ul>
<p>任何一个promise兑现时兑现，全部被拒绝时才会拒绝</p>
<ul>
<li>Promise.race()</li>
</ul>
<p>也接收一个包含多个Promise的数组，但只要其中一个Promise解决或拒绝，就返回结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;first&quot;</span>));<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">500</span>,<span class="hljs-string">&quot;second&quot;</span>));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1, promise2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// &quot;second&quot; (因为 promise2 更快解决)</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>Promise.allSettled()</li>
</ul>
<p>当所有 Promise 都完成（无论是成功还是失败）时，返回的 Promise 状态才会是Fulfilled。与 <code>Promise.all()</code> 不同的是，它不会在有一个 Promise 失败时立即失败，而是等到所有 Promise 都完成之后，返回每个 Promise 的状态和结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);<br>  <span class="hljs-comment">// [</span><br>  <span class="hljs-comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 1 &#125;,</span><br>  <span class="hljs-comment">//   &#123; status: &#x27;rejected&#x27;, reason: &#x27;error&#x27; &#125;,</span><br>  <span class="hljs-comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 3 &#125;</span><br>  <span class="hljs-comment">// ]</span><br>&#125;);<br></code></pre></td></tr></table></figure>



<h5 id="🌈其他（有些不解）"><a href="#🌈其他（有些不解）" class="headerlink" title="🌈其他（有些不解）"></a>🌈其他（有些不解）</h5><ul>
<li><code>promise.then().then().then()</code> 结构使得错误能够被捕获并集中处理，任何一个 <code>then</code> 中的错误都会被链中的 <code>catch</code> 捕获。</li>
<li>使用 <code>new Promise((resolve, reject) =&gt; &#123; ... &#125;)</code> 允许你在定义异步操作的过程中控制 Promise 的状态，成功和失败的状态可以直接通过调用 <code>resolve</code> 和 <code>reject</code> 来管理，从而实现代码的截断。</li>
</ul>
<h4 id="13、深拷贝和浅拷贝"><a href="#13、深拷贝和浅拷贝" class="headerlink" title="13、深拷贝和浅拷贝"></a>13、深拷贝和浅拷贝</h4><h5 id="🦛浅拷贝"><a href="#🦛浅拷贝" class="headerlink" title="🦛浅拷贝"></a>🦛浅拷贝</h5><blockquote>
<p>对象的<strong>浅拷贝</strong>是属性与拷贝的源对象属性共享相同的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Object_reference">引用</a>（指向相同的底层值）的副本。因此，当你更改源对象或副本时，也可能导致另一个对象发生更改。与之相比，在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Deep_copy">深拷贝</a>中，源对象和副本是完全独立的。</p>
</blockquote>
<p>对于浅拷贝，只有顶层属性被复制，而不是嵌套对象的值。因此：</p>
<ul>
<li>对副本的顶层属性的重新赋值不会影响源对象。</li>
<li>对副本的嵌套对象属性的重新赋值会影响源对象。</li>
</ul>
<p>在 JavaScript 中，所有标准内置对象复制操作（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">扩展语法</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat"><code>Array.prototype.concat()</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"><code>Array.prototype.slice()</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from"><code>Array.from()</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a>）都创建浅拷贝，而不是深拷贝。</p>
<p>除此之外，这些也是浅拷贝</p>
<ul>
<li>使用拓展运算符：const shallowCopy &#x3D; { …obj1 }</li>
<li>直接相等：obj1&#x3D;obj2</li>
</ul>
<h5 id="🦛深拷贝"><a href="#🦛深拷贝" class="headerlink" title="🦛深拷贝"></a>🦛深拷贝</h5><p>定义深拷贝：</p>
<ol>
<li>它们不是同一个对象（<code>o1 !== o2</code>）。</li>
<li><code>o1</code> 和 <code>o2</code> 的属性具有相同的名称且顺序相同。</li>
<li>它们的属性的值是彼此的深拷贝。</li>
<li>它们的原型链是结构等价的。</li>
</ol>
<ul>
<li>方法一：JSON.parse(JSON.stringify())<ul>
<li>对象的属性是函数时无法拷贝</li>
<li>原型链上的属性无法拷贝</li>
<li>无法处理Date&#x2F;RegExp这种复杂类型</li>
<li>会忽略Symbol和undefined</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ingredients_list = [<span class="hljs-string">&quot;noodles&quot;</span>, &#123; <span class="hljs-attr">list</span>: [<span class="hljs-string">&quot;eggs&quot;</span>, <span class="hljs-string">&quot;flour&quot;</span>, <span class="hljs-string">&quot;water&quot;</span>] &#125;];<br><span class="hljs-keyword">let</span> ingredients_list_deepcopy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(ingredients_list));<br></code></pre></td></tr></table></figure>

<ul>
<li>方法二：structuredClone()（支持Date等复杂类型）</li>
<li>方法三：Lodash的_.cloneDeep（不支持DOM节点等特定对象）</li>
</ul>
<h4 id="14、箭头函数"><a href="#14、箭头函数" class="headerlink" title="14、箭头函数"></a>14、箭头函数</h4><ul>
<li>箭头函数没有独立的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this"><code>this</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Binding">绑定</a>，并且不可被用作<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Method">方法</a>。</li>
<li>箭头函数不能用作<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Constructor">构造函数</a>。使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a> 调用它们会引发 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a>。它们也无法访问 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target"><code>new.target</code></a> 关键字。</li>
<li>箭头函数不能在其主体中使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield"><code>yield</code></a>，也不能作为生成器函数创建。</li>
</ul>
<p>以下三种情况访问this不会输出undefined：</p>
<h5 id="🦤在类中使用箭头函数"><a href="#🦤在类中使用箭头函数" class="headerlink" title="🦤在类中使用箭头函数"></a>🦤在类中使用箭头函数</h5><p>在类的方法中定义箭头函数，箭头函数会继承类实例的 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>=value;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">func</span>=<span class="hljs-function">()=&gt;</span>&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>      &#125;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">const</span> instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-number">42</span>);<br>instance.<span class="hljs-title function_">func</span>();   <span class="hljs-comment">//输出42</span><br></code></pre></td></tr></table></figure>

<h5 id="🦤在另一个函数的作用域中定义箭头函数"><a href="#🦤在另一个函数的作用域中定义箭头函数" class="headerlink" title="🦤在另一个函数的作用域中定义箭头函数"></a>🦤在另一个函数的作用域中定义箭头函数</h5><p>如果在一个函数内定义箭头函数，<code>this</code> 将指向该函数的上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value</span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>   &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> fun=<span class="hljs-title function_">func</span>(<span class="hljs-number">42</span>);<br><span class="hljs-title function_">fun</span>();   <span class="hljs-comment">//输出42</span><br></code></pre></td></tr></table></figure>

<h5 id="🦤在-setTimeout-中使用箭头函数"><a href="#🦤在-setTimeout-中使用箭头函数" class="headerlink" title="🦤在 setTimeout 中使用箭头函数"></a>🦤在 setTimeout 中使用箭头函数</h5><p>如果在 <code>setTimeout</code> 等异步函数中使用箭头函数，它会继承 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj=&#123;<br>   <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>,<br>   <span class="hljs-attr">func</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>      &#125;,<span class="hljs-number">1000</span>);<br>   &#125;<br>&#125;<br>obj.<span class="hljs-title function_">func</span>();  <span class="hljs-comment">//一秒后输出42</span><br></code></pre></td></tr></table></figure>



<h4 id="15、如何判断是数组"><a href="#15、如何判断是数组" class="headerlink" title="15、如何判断是数组"></a>15、如何判断是数组</h4><ul>
<li>Array.isArray() （最推荐的方法，返回true&#x2F;false）</li>
<li>instanceof（arr instanceof Array）（返回true&#x2F;false）</li>
<li>Object.prototype.toString.call()</li>
<li>constructor（arr.constructor&#x3D;&#x3D;&#x3D;Array）（返回true&#x2F;false）</li>
</ul>
<h4 id="16、for-in和for-of和forEach"><a href="#16、for-in和for-of和forEach" class="headerlink" title="16、for in和for of和forEach"></a>16、for in和for of和forEach</h4><h5 id="🐥for-in"><a href="#🐥for-in" class="headerlink" title="🐥for in"></a>🐥for in</h5><p><code>for...in</code> 用于遍历对象的可枚举属性，包括对象自身的属性和继承自原型链的属性。</p>
<ul>
<li><code>for...in</code> 循环会遍历对象的所有可枚举属性，包括继承的属性。</li>
<li>使用 <code>hasOwnProperty</code> 方法可以避免遍历原型链上的属性。</li>
<li>不建议用 <code>for...in</code> 遍历数组，因为它会遍历数组的索引，且不保证顺序。</li>
</ul>
<h5 id="🐥for-of"><a href="#🐥for-of" class="headerlink" title="🐥for of"></a>🐥for of</h5><p><code>for...of</code> 用于遍历可迭代对象（如数组、字符串、Map、Set 等），获取其值。</p>
<ul>
<li><code>for...of</code> 只会遍历可迭代对象的值，不会遍历对象的属性。</li>
<li>适合用于数组、字符串等数据结构的遍历。</li>
</ul>
<h5 id="🐥forEach"><a href="#🐥forEach" class="headerlink" title="🐥forEach"></a>🐥forEach</h5><p>是一种迭代方法，按照索引升序为数组中的每个元素调用一次提供的callbackFn函数。它总是返回undefined，而不能链式调用。（不会在空槽上调用）</p>
<p>除非抛出异常，否则没有办法停止或中断 <code>forEach()</code> 循环。如果有这样的需求，则不应该使用 <code>forEach()</code> 方法。</p>
<p><code>forEach()</code> 期望的是一个同步函数，它不会等待 Promise 兑现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ratings = [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumFunction</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br>ratings.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">async</span> (rating) =&gt; &#123;<br>  sum = <span class="hljs-keyword">await</span> <span class="hljs-title function_">sumFunction</span>(sum, rating);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br><span class="hljs-comment">// 期望的输出：14</span><br><span class="hljs-comment">// 实际的输出：0</span><br></code></pre></td></tr></table></figure>





<h4 id="17、async-await"><a href="#17、async-await" class="headerlink" title="17、async&#x2F;await"></a>17、async&#x2F;await</h4><p><code>async</code>：用于声明一个函数为异步函数。异步函数会返回一个 <code>Promise</code>，即使函数内部没有明确返回 <code>Promise</code>，JavaScript 也会自动将其转换为 <code>Promise</code>。（不一定要和await一起）</p>
<p><code>await</code>：用于等待一个 <code>Promise</code> 被解决（fulfilled）或被拒绝（rejected）。**<code>await</code> 只能在 <code>async</code> 函数内部使用**。</p>
<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;错误:&quot;</span>, error);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">getData</span>();<br></code></pre></td></tr></table></figure>

<h5 id="结合promise"><a href="#结合promise" class="headerlink" title="结合promise"></a>结合promise</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchAllData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> [data1, data2] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>            <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data1&#x27;</span>),<br>            <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data2&#x27;</span>)<br>        ]);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1, data2);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;错误:&quot;</span>, error);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchAllData</span>();<br></code></pre></td></tr></table></figure>



<h4 id="18、arguments"><a href="#18、arguments" class="headerlink" title="18、arguments"></a>18、arguments</h4><blockquote>
<p><code>arguments</code> 是一个<strong>类数组对象</strong>，代表传递给函数的所有参数。它在函数内部可用，用于访问函数的参数，无论参数是如何传递的</p>
</blockquote>
<h5 id="🦩基本用法"><a href="#🦩基本用法" class="headerlink" title="🦩基本用法"></a>🦩基本用法</h5><p>在函数内部，可以使用 <code>arguments</code> 关键字来访问传入的参数。<code>arguments</code> 是一个类似数组的对象，但不是数组，因此没有数组的方法，比如 <code>push</code>、<code>pop</code> 等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">exampleFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 打印所有传入的参数</span><br>&#125;<br><br><span class="hljs-title function_">exampleFunction</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 输出: [1, 2, 3, &quot;hello&quot;]</span><br></code></pre></td></tr></table></figure>

<h5 id="🦩转换为数组"><a href="#🦩转换为数组" class="headerlink" title="🦩转换为数组"></a>🦩转换为数组</h5><ul>
<li>使用Array.from：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">exampleFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> argsArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(argsArray); <span class="hljs-comment">// [1,2,3]</span><br>&#125;<br><span class="hljs-title function_">exampleFunction</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>使用拓展运算符：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">exampleFunction</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <br>&#125;<br><span class="hljs-title function_">exampleFunction</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>



<h4 id="19、this的指向和绑定规则"><a href="#19、this的指向和绑定规则" class="headerlink" title="19、this的指向和绑定规则"></a>19、this的指向和绑定规则</h4><h5 id="🐥全局上下文"><a href="#🐥全局上下文" class="headerlink" title="🐥全局上下文"></a>🐥全局上下文</h5><p>在全局作用域中，<code>this</code> 指向全局对象：</p>
<ul>
<li>在浏览器中，<code>this</code> 指向 <code>window</code> 对象。</li>
<li>在 Node.js 中，<code>this</code> 指向 <code>global</code> 对象。</li>
</ul>
<h5 id="🐥函数调用"><a href="#🐥函数调用" class="headerlink" title="🐥函数调用"></a>🐥函数调用</h5><p>在普通函数中调用 <code>this</code>，它指向调用该函数的对象。如果函数是通过对象调用的，<code>this</code> 指向该对象；如果是全局调用，<code>this</code> 指向全局对象（在严格模式下为 <code>undefined</code>）。</p>
<h5 id="🐥对象方法"><a href="#🐥对象方法" class="headerlink" title="🐥对象方法"></a>🐥对象方法</h5><p>当一个方法被调用时，<code>this</code> 指向调用该方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br>person.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, Alice&quot;</span><br></code></pre></td></tr></table></figure>

<h5 id="🐥构造函数"><a href="#🐥构造函数" class="headerlink" title="🐥构造函数"></a>🐥构造函数</h5><p>当通过new关键字调用构造函数的时候，this指向新创建的实例对象</p>
<h5 id="🐥箭头函数"><a href="#🐥箭头函数" class="headerlink" title="🐥箭头函数"></a>🐥箭头函数</h5><p>箭头函数没有自己的this，他从外部上下文（定义时的上下文）继承this的值</p>
<h5 id="🐥call、apply、bind"><a href="#🐥call、apply、bind" class="headerlink" title="🐥call、apply、bind"></a>🐥call、apply、bind</h5><p> <code>call</code>、<code>apply</code> 和 <code>bind</code> 方法来显式地绑定 <code>this</code> 的指向。</p>
<h5 id="🐥事件处理程序"><a href="#🐥事件处理程序" class="headerlink" title="🐥事件处理程序"></a>🐥事件处理程序</h5><p>在事件处理程序中，<code>this</code> 通常指向触发事件的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> button=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);   <span class="hljs-comment">//指向button元素</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="🐥严格模式"><a href="#🐥严格模式" class="headerlink" title="🐥严格模式"></a>🐥严格模式</h5><ul>
<li>未绑定的 <code>this</code> 在函数中会是 <code>undefined</code>，而不是全局对象。</li>
<li>如果希望在函数中访问 <code>this</code>，应该将其作为对象的方法调用，或者使用 <code>bind</code> 进行绑定。局部变量不会影响 <code>this</code> 的上下文。</li>
</ul>
<h4 id="20、如何解决script标签阻碍DOM的解析"><a href="#20、如何解决script标签阻碍DOM的解析" class="headerlink" title="20、如何解决script标签阻碍DOM的解析"></a>20、如何解决script标签阻碍DOM的解析</h4><h5 id="🐵使用defer属性"><a href="#🐵使用defer属性" class="headerlink" title="🐵使用defer属性"></a>🐵使用defer属性</h5><p>当在 <code>&lt;script&gt;</code> 标签中添加 <code>defer</code> 属性时，浏览器会在 HTML 解析完成后再执行脚本。此时，DOM 已经构建完成，因此可以安全地操作 DOM。</p>
<h5 id="🐵将-标签放在-的底部："><a href="#🐵将-标签放在-的底部：" class="headerlink" title="🐵将 &lt;script&gt; 标签放在 &lt;body&gt; 的底部："></a>🐵<strong>将 &lt;<code>script</code>&gt; 标签放在 <code>&lt;body&gt;</code> 的底部</strong>：</h5><p>将脚本放在 <code>&lt;body&gt;</code> 标签的结束标签之前，这样可以确保在执行脚本时，DOM 已经构建完成。</p>
<h4 id="21、变量提升"><a href="#21、变量提升" class="headerlink" title="21、变量提升"></a>21、变量提升</h4><p>指的是变量和函数声明在代码执行之前被提升到其所在的作用域的顶部。这意味着无论你在代码的哪个位置声明变量，JavaScript 在执行代码时都会将其提升到该作用域的顶部。</p>
<h5 id="🐎基本原理"><a href="#🐎基本原理" class="headerlink" title="🐎基本原理"></a>🐎基本原理</h5><ul>
<li>变量声明：在 JavaScript 中，只有变量的声明会被提升，而赋值不会被提升。</li>
<li>函数提升：函数声明也会被提升，允许在函数声明之前调用该函数。</li>
</ul>
<h5 id="🐎变量提升"><a href="#🐎变量提升" class="headerlink" title="🐎变量提升"></a>🐎变量提升</h5><p>由于只有声明被提升而赋值没有，所以输出的是undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 输出: undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 输出: 10</span><br></code></pre></td></tr></table></figure>

<p>使用let和const声明的变量不会被提升到顶部，访问他们会导致暂时性死区，即在生命之前访问变量会抛出错误。</p>
<h5 id="🐎函数提升"><a href="#🐎函数提升" class="headerlink" title="🐎函数提升"></a>🐎函数提升</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出: &quot;Hello, world!&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用函数表达式（如将函数赋值给一个变量），则不会提升该变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 报错: TypeError: foo is not a function</span><br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Function expression&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="22、模板字符串"><a href="#22、模板字符串" class="headerlink" title="22、模板字符串"></a>22、模板字符串</h4><ul>
<li>模板字符串允许在 <code>$&#123;&#125;</code> 中插入变量或表达式，构成动态内容（会自动运算）</li>
<li>可以直接编写多行字符串，无需添加换行符 <code>\n</code> 或使用 <code>+</code> 拼接</li>
<li>在模板字符串中可以直接调用函数，将返回值嵌入字符串</li>
<li>模板字符串中可以嵌套其他模板字符串，形成动态构建内容</li>
</ul>
<h4 id="23、getter和setter"><a href="#23、getter和setter" class="headerlink" title="23、getter和setter"></a>23、getter和setter</h4><h5 id="🐣getter"><a href="#🐣getter" class="headerlink" title="🐣getter"></a>🐣getter</h5><p>get语法将对象属性绑定到查询该属性时将被调用的函数。（有时需要动态访问计算属性的值，或者需要反应内部变量的状态，而不需要显示方法调用，可以用getter实现）</p>
<ul>
<li>它不能与另一个 <code>get</code> 或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 <code>&#123; get x() &#123; &#125;, get x() &#123; &#125; &#125;</code> 和 <code>&#123; x: ..., get x() &#123; &#125; &#125;</code>）。</li>
<li>getter 延迟计算值的成本，直到需要此值，如果不需要，你就不用支付成本。该值是在第一次调用 getter 时计算的，然后被缓存，因此后续访问返回缓存值而不重新计算它。这意味着你不应该为你希望更改其值的属性使用懒 getter，因为 getter 不会重新计算该值。</li>
<li>可以使用delete操作符删除一个getter：delete obj.getter</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj=&#123;<br>   <span class="hljs-attr">log</span>: [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>],<br>   <span class="hljs-keyword">get</span> <span class="hljs-title function_">latest</span>() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">log</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">log</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>];<br>   &#125;,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">latest</span>);  <span class="hljs-comment">//&#x27;c&#x27;</span><br></code></pre></td></tr></table></figure>



<h5 id="🐣setter"><a href="#🐣setter" class="headerlink" title="🐣setter"></a>🐣setter</h5><p>当尝试设置属性时，**<code>set</code>** 语法将对象属性绑定到要调用的函数。</p>
<p>在 javascript 中，如果试着改变一个属性的值，那么对应的 setter 将被执行。setter 经常和 getter 连用以创建一个伪属性。不可能在具有真实值的属性上同时拥有一个 setter 器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> lan=&#123;<br>   <span class="hljs-keyword">set</span> <span class="hljs-title function_">current</span>(<span class="hljs-params">name</span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">log</span>.<span class="hljs-title function_">push</span>(name);<br>   &#125;,<br>   <span class="hljs-attr">log</span>: [],<br>&#125;<br>lan.<span class="hljs-property">current</span>=<span class="hljs-string">&quot;EN&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lan.<span class="hljs-property">log</span>);<br></code></pre></td></tr></table></figure>



<h4 id="24、Generator和yield"><a href="#24、Generator和yield" class="headerlink" title="24、Generator和yield"></a>24、Generator和yield</h4><p>生成器和yield是用于处理异步编程和迭代的工具。生成器是一种特殊类型的函数，可以在执行过程中暂停，并在稍后继续执行。</p>
<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>是用function*定义的函数，返回一个生成器对象，该对象用于控制函数的执行</p>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h5><p>yield关键字用于暂停函数的执行并返回一个值。每当生成器遇到yield1语句，都会返回yield后面的值，并暂停执行，直到生成器的next()方法被调用。</p>
<h4 id="25、async-await"><a href="#25、async-await" class="headerlink" title="25、async&#x2F;await"></a>25、async&#x2F;await</h4><p>是generator的语法糖。WHY？</p>
<ul>
<li>async函数内置执行器，函数调用后会立即执行；Generator里需要配合next模块使用</li>
<li>更好的语义，async表示有异步操作，await表示紧跟在后面的表达式需要等待结果</li>
<li>返回值是promise。generator返回的是迭代器</li>
</ul>
<h4 id="26、requestAnimationFrame"><a href="#26、requestAnimationFrame" class="headerlink" title="26、requestAnimationFrame"></a>26、requestAnimationFrame</h4><p>在它之前，我们使用setTimeout&#x2F;setInterval来编写JS动画。</p>
<p>编写动画的关键是循环间隔的设置，一方面循环间隔足够段，动画效果才能显得平滑流畅；另一方面，循环间隔要足够长，才能保证浏览器有能力渲染产生的变化。1000ms&#x2F;60</p>
<p>setTimeout&#x2F;setInterval有一个显著的缺点在于，时间是不精确的，只能保证延时或者间隔不小于设定的时间。因为它们只是把任务添加到了任务队列中，但是如果前面的任务还没有执行完成，就必须要等待。</p>
<p>requestAnimationFrame采用的是系统时间间隔，可以保持最佳绘制效率，不会因为间隔过短导致过度绘制，增加开销，也不会因为间隔过长导致动画卡顿不流畅。可以让各种网页动画有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p>
<p>优点：</p>
<ul>
<li><p>不需要设置时间，采用系统时间间隔，达到最佳动画效果</p>
</li>
<li><p>会把每一帧所有的DOM操作集中起来，再一次重绘或回流中完成</p>
</li>
<li><p>如果运行在后台或隐藏的<code>&lt;iframe&gt;</code>里，会被暂停调用以提升性能</p>
</li>
</ul>
<h4 id="27、ES6和CommonJS的差异"><a href="#27、ES6和CommonJS的差异" class="headerlink" title="27、ES6和CommonJS的差异"></a>27、ES6和CommonJS的差异</h4><h5 id="🐄导入导出方式"><a href="#🐄导入导出方式" class="headerlink" title="🐄导入导出方式"></a>🐄导入导出方式</h5><ul>
<li>ES6使用import&#x2F;export关键字处理导入导出，default关键字处理默认导出</li>
<li>CommonJS使用require&#x2F;module.exports用于导入和导出</li>
</ul>
<h5 id="🐄加载机制"><a href="#🐄加载机制" class="headerlink" title="🐄加载机制"></a>🐄加载机制</h5><ul>
<li>ES6基于静态加载，在编译时就确定依赖关系，import会被提升，在文件顶部执行</li>
<li>CommonJS基于动态加载，只有代码执行到require时才会加载模块（同步加载）</li>
</ul>
<h5 id="🐄执行顺序和作用域"><a href="#🐄执行顺序和作用域" class="headerlink" title="🐄执行顺序和作用域"></a>🐄执行顺序和作用域</h5><ul>
<li>ES6：每个模块都有独立的顶层作用域，不会污染全局作用域<ul>
<li>自动启动严格模式，顶层this指向undefined</li>
<li>如果多个模块引用同一个模块，会被缓存且加载一次</li>
</ul>
</li>
<li>CommonJSthis指向当前模块，也有上述缓存机制</li>
</ul>
<h5 id="🐄使用场景"><a href="#🐄使用场景" class="headerlink" title="🐄使用场景"></a>🐄使用场景</h5><ul>
<li>ES6更适合在现代浏览器中使用</li>
<li>CommonJS主要用于Node.js环境，适合服务器端开发</li>
</ul>
<h5 id="🐄兼容性"><a href="#🐄兼容性" class="headerlink" title="🐄兼容性"></a>🐄兼容性</h5><ul>
<li>ES6如果在Node.js中使用需要开启“type：module”或者将文件扩展名设置为.mjs</li>
<li>CommonJS：Node.js默认支持CommonJS模块</li>
</ul>
<h4 id="28、事件代理"><a href="#28、事件代理" class="headerlink" title="28、事件代理"></a>28、事件代理</h4><p>通过将事件处理程序添加到父级元素来管理多个子元素的事件，而不是给每个子元素分别绑定事件。可以提高性能，尤其是在动态添加或删除子元素的情况下。</p>
<h5 id="💦原理"><a href="#💦原理" class="headerlink" title="💦原理"></a>💦原理</h5><p>利用的是事件冒泡。当一个元素上的事件触发时，事件会从目标元素逐级向上冒泡到父级元素，直到document或者window为止。事件代理的机制是将事件处理程序绑定在一个父级容器上，事件触发时，通过父容器捕获事件，并通过判断事件目标（event.target）来确定触发的实际子元素。</p>
<h5 id="💦实例"><a href="#💦实例" class="headerlink" title="💦实例"></a>💦实例</h5><p>假设有一个列表，每个列表项都需要响应点击事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可以将事件监听器放在列表的父容器，而不是单独给每个li单独绑定事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);<br>list.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>   <span class="hljs-keyword">if</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span>===<span class="hljs-string">&quot;li&quot;</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Click&quot;</span>);<br>   &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>如果动态添加元素到列表，新的子元素也会响应同样的实践</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newItem=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>newItem.<span class="hljs-property">textContent</span>=<span class="hljs-string">&#x27;Item4&#x27;</span>;<br>list.<span class="hljs-title function_">appendChild</span>(newItem);<br></code></pre></td></tr></table></figure>



<h4 id="29、代码分析"><a href="#29、代码分析" class="headerlink" title="29、代码分析"></a>29、代码分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>   getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)&#125;;<br>   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)&#125;;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)&#125;;<br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)&#125;;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>();<br><span class="hljs-title function_">getName</span>();<br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();<br><span class="hljs-title function_">getName</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();<br></code></pre></td></tr></table></figure>



<h4 id="30、JS执行上下文栈和作用域链"><a href="#30、JS执行上下文栈和作用域链" class="headerlink" title="30、JS执行上下文栈和作用域链"></a>30、JS执行上下文栈和作用域链</h4><h5 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h5><p>是当前JS代码被解析和执行时所在的环境的抽象概念，JS中运行任何代码都是在执行上下文中运行。分为：全局执行上下文和函数执行上下文。</p>
<p>执行上下文创建过程中，需要做：</p>
<ul>
<li>创建变量对象：初始化函数的参数args，提升函数声明和变量声明</li>
<li>创建作用域链</li>
<li>确定this的值</li>
</ul>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套严格的规则确定当前执行的代码对这些标识符的访问权限。</p>
<p>分为：</p>
<ul>
<li>全局作用域：代码中任何地方都可以访问（最外层的变量）；在整个程序中始终存在直到页面或者脚本关闭；浏览器中是window对象的属性，node环境中是global对象的</li>
<li>函数作用域：在函数中定义的变量只在函数内部有效</li>
<li>块级作用域：在{}大括号内声明的变量和常量（使用let、const声明）仅在快内部有效，外部无法访问。（避免变量在循环或条件语句中意外污染全局作用域）</li>
</ul>
<h5 id="执行上下文栈（即执行栈）"><a href="#执行上下文栈（即执行栈）" class="headerlink" title="执行上下文栈（即执行栈）"></a>执行上下文栈（即执行栈）</h5><p>也叫调用栈，用于存储在代码执行期间创建的所有执行上下文</p>
<ul>
<li>首次运行JS代码的时候，会创建一个全局的执行上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶</li>
<li>当栈顶的函数运行完成后，对应的函数执行上下文会从执行栈Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。</li>
</ul>
<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到就宣布放弃。这种一层一层的关系就是作用域链。</p>
<h4 id="31、WeakMap、WeakSet"><a href="#31、WeakMap、WeakSet" class="headerlink" title="31、WeakMap、WeakSet"></a>31、WeakMap、WeakSet</h4><p>用于存储对象的引用，同时不防止其被垃圾回收。</p>
<ul>
<li>键必须是对象，键是弱引用，意味着如果没有其他引用指向该对象，垃圾回收器可以自动回收这个对象，减少内存泄露的风险。</li>
<li>不支持遍历。意味着不能获取其键或值的列表。</li>
</ul>
<p>假设你在开发一个单页应用（SPA），在其中频繁创建和销毁 DOM 元素。你可能希望将某些数据与这些元素关联，但又不想让它们持续占用内存。</p>
<p>在某些情况下，你需要确保某个对象只能被存储一次。例如，在某些应用中，可能需要跟踪已处理的 DOM 元素或事件处理程序。</p>
<h4 id="、事件循环"><a href="#、事件循环" class="headerlink" title="、事件循环"></a>、事件循环</h4><blockquote>
<p>JavaScript 的事件循环（Event Loop）是理解其异步行为和非阻塞特性的核心概念。事件循环使得 JavaScript 能够处理事件和异步操作，尽管它是单线程的。</p>
</blockquote>
<p><strong>事件循环机制确保了 JavaScript 的异步执行能力，使其能够在单线程环境下有效地处理事件和异步任务。</strong></p>
<p>JavaScript 有一个基于<strong>事件循环</strong>的运行时模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其他语言中的模型截然不同，比如 C 和 Java。</p>
<img src="https://cdn.jsdelivr.net/gh/Yaodeer/pict@main/image-20241029125906648.png" srcset="/img/loading.gif" lazyload alt="image-20241029125906648" style="zoom:67%;" />

<h5 id="🔺执行栈"><a href="#🔺执行栈" class="headerlink" title="🔺执行栈"></a>🔺执行栈</h5><p>JS使用执行栈来管理执行上下文；</p>
<p>当函数被调用时，会被推入栈顶；当函数执行完成后，会从栈中弹出。</p>
<h5 id="🔺任务队列"><a href="#🔺任务队列" class="headerlink" title="🔺任务队列"></a>🔺任务队列</h5><p>当异步操作完成（如setTimeout、事件监听等），相关的回调函数会被放入任务队列；</p>
<p>任务队列是用于存放等待执行的任务的队列。</p>
<h5 id="🔺微任务队列"><a href="#🔺微任务队列" class="headerlink" title="🔺微任务队列"></a>🔺微任务队列</h5><p>微任务队列用于处理更高优先级的任务，通常包括Promise的回调函数。</p>
<p>微任务队列的执行优先级高于任务队列。</p>
<h5 id="🐡事件循环的工作原理"><a href="#🐡事件循环的工作原理" class="headerlink" title="🐡事件循环的工作原理"></a>🐡事件循环的工作原理</h5><ul>
<li><p>执行栈检查：</p>
<ul>
<li>如果执行栈为空，事件循环会检查微任务队列</li>
</ul>
</li>
<li><p>处理微任务：</p>
<ul>
<li>如果微任务队列不为空，事件循环会从微任务队列中取出任务并执行，直到微任务队列为空</li>
</ul>
</li>
<li><p>处理任务：</p>
<ul>
<li>之后，事件循环会从任务队列中取出一个任务并执行</li>
</ul>
</li>
<li><p>重复循环：</p>
<ul>
<li>重复以上步骤，直到所有任务和微任务都被执行完毕</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;,<span class="hljs-number">0</span>);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>   <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>   &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>输出： 2 4 3 5 1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span>&#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">throw</span>(<span class="hljs-number">1</span>);<br>   &#125;,<span class="hljs-number">0</span>)<br>&#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：2 undifined（由于异步，没catch到错误）</p>
<p>队列：</p>
<ul>
<li>JS运行时包含一个待处理消息的消息队列。每一个消息都关联着用以处理这个消息的回调函数。在事件循环期间的某个时刻，运行时会开始处理最先进入队列的消息。被处理的消息会移出队列，并作为输入参数来调用与之关联的函数。正如前面提到的，调用一个函数总是会为其创造一个新的栈帧。</li>
<li>函数的处理会一直到执行栈再次为空为止，然后事件循环将会处理队列中的下一个消息（如果还有的话）。</li>
</ul>
<p><strong>每一个消息完整地执行后，其他消息才会被执行。</strong></p>
<p>当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。</p>
<p>在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。然而，一些事件同步发生，没有产生消息——例如，通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/click"><code>click</code></a> 方法模拟的点击。</p>
<p>函数 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout"><code>setTimeout()</code></a> 接受的前两个参数：一个是待加入队列的消息，一个是时间值（可选，默认为 0）。这个<em>时间值</em>代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其他消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。然而，如果有其他消息，<code>setTimeout()</code> 消息必须等待其他消息处理完。因此第二个参数仅仅表示<em>最少</em>延迟时间，而非<em>确切</em>的等待时间。</p>
<p>以 0 为第二参数调用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout"><code>setTimeout()</code></a> 并不表示在 0 毫秒后就调用回调函数。</p>
<p>其等待的时间取决于队列里待处理的消息数量。在下面的例子中，<code>&quot;这是一条消息&quot;</code> 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的<em>最小</em>等待时间，但并不保证是<em>准确</em>的等待时间。</p>
<p>基本上，<code>setTimeout()</code> 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间</p>
<p>JavaScript 的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。处理 I&#x2F;O 通常通过事件和回调来执行，所以当应用程序正等待一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB</a> 查询返回或者一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/fetch"><code>fetch()</code></a> 请求返回时，它仍然可以处理其他事情，比如用户输入。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%85%AB%E8%82%A1%E9%9D%A2%E7%BB%8F/" class="category-chain-item">八股面经</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/c/" class="print-no-link">#c++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端八股总结-JS（持续更新）</div>
      <div>http://example.com/2024/10/23/前端八股总结-JS/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Yaodeer</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>October 23, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/10/23/CPP%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%93/" title="CPP八股总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CPP八股总结</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/23/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%93-CSS+HTML+%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/" title="前端八股总结-CSS+HTML+页面渲染（持续更新）">
                        <span class="hidden-mobile">前端八股总结-CSS+HTML+页面渲染（持续更新）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://comment-three-kappa.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":500,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://yaodeer.github.io/2024/04/12/About%20Me/" target="_blank" rel="nofollow noopener"><span>2024</span></a> <i class="iconfont icon-love"></i> <a href="https://yaodeer.github.io/2024/04/12/About%20Me/" target="_blank" rel="nofollow noopener"><span>Yaodeer</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
